---
title: "Trapdiff"
output: flexdashboard::flex_dashboard
params:
  path_out: "./"
  path_de: "/beegfs/scratch/bruening_scratch/pklemm/rpackages/trapdiff/inst/rmd/trapdiff/de.rds"
  path_col_data: "/beegfs/scratch/bruening_scratch/pklemm/rpackages/trapdiff/inst/rmd/trapdiff/col_data.rds"
  path_counts: "/beegfs/scratch/bruening_scratch/pklemm/rpackages/trapdiff/inst/rmd/trapdiff/counts.rds"
---

```{r setup}
library(magrittr)
suppressWarnings(library(rmyknife))
# Put params into separate object because sometimes params
# get's inaccessible when developing with xaringan
rmd_params <- params
# Dynamic variable for input select
gene_select <- shiny::reactiveVal()
ggplot2::theme_set(ggplot2::theme_light())
```

## Inputs {.sidebar data-width=300 data-height=800}

<details>
<summary>Show configuration</summary>

```{r show-run-config, paged.print = TRUE}
# Print settings as table
rmyknife::print_params(rmd_params)
```

```{r load-data}
col_data <- readRDS(rmd_params$path_col_data)
counts <- readRDS(rmd_params$path_counts)
de <- readRDS(rmd_params$path_de) %>%
  dplyr::mutate(gene_id = glue::glue("{ensembl_gene_id}_{external_gene_name}"))
de_wide <- de %>%
  tidyr::pivot_wider(
    names_from = comparison,
    values_from = c(padj, log2FoldChange)
  )

treatment_a <- col_data$treatment %>%
  levels() %>%
  .[1]
treatment_b <- col_data$treatment %>%
  levels() %>%
  .[2]
source_a <- col_data$source %>%
  levels() %>%
  .[1]
source_b <- col_data$source %>%
  levels() %>%
  .[2]

main_effect_a_comparison_name <- glue::glue("main_in_source_a___{treatment_a}_vs_{treatment_b}_in_{source_a}")
main_effect_b_comparison_name <- glue::glue("main_in_source_b___{treatment_a}_vs_{treatment_b}_in_{source_b}")
source_effect_a_comparison_name <- glue::glue("source_in_main_a___{source_a}_vs_{source_b}_in_{treatment_a}")
source_effect_b_comparison_name <- glue::glue("source_in_main_b___{source_a}_vs_{source_b}_in_{treatment_b}")

tibble::tibble(
  condition = c("a", "b"),
  treatment = c(treatment_a, treatment_b),
  source = c(source_a, source_b)
) %>%
  knitr::kable()
```

</details>

```{r}
fc_scatterplot <-
  function(
           ggplot_dat,
           colour_lab,
           title,
           x_lab = "fc_ip",
           y_lab = "fc_input",
           point_alpha = 0.3,
           min_range = -5,
           max_range = 5) {
    ggplot_dat +
      ggplot2::geom_point(
        alpha = point_alpha
      ) +
      ggplot2::scale_x_continuous(limits = c(min_range, max_range)) +
      ggplot2::scale_y_continuous(limits = c(min_range, max_range)) +
      ggplot2::labs(
        # x = x_lab,
        # y = y_lab,
        colour = colour_lab
      ) +
      # ggplot2::scale_size(trans = 'reverse') +
      ggplot2::scale_color_distiller(palette = "RdBu", type = "div", direction = -1, limits = c(min_range, max_range)) +
      ggplot2::theme_minimal() +
      ggplot2::ggtitle(title)
  }

shiny::renderUI({
  # Handle inputs from datatable (very hacky!)
  selected_id <- get_first_selected_in_dt(input)
  if (!is.null(selected_id)) {
    print(selected_id)
    selected_gene <- de_wide %>%
      apply_filter() %>%
      dplyr::slice(selected_id) %>%
      .$gene_id
    print(selected_gene)
    gene_select(selected_gene)
  }

  shiny::selectInput(
    "gene_id",
    "Highlight gene",
    choices = de_wide %>%
      dplyr::select(gene_id) %>%
      dplyr::distinct() %>%
      dplyr::pull(),
    # Get default selection from dynamic variable
    selected = gene_select()
  )
}) 

shiny::checkboxGroupInput(
  "select_significant",
  label = "Filter significant genes",
  choices = tibble::tibble(
    !!(main_effect_a_comparison_name) := main_effect_a_comparison_name,
    !!(main_effect_b_comparison_name) := main_effect_b_comparison_name,
    !!(source_effect_a_comparison_name) := source_effect_a_comparison_name,
    !!(source_effect_b_comparison_name) := source_effect_b_comparison_name,
    interaction_effect = "interaction_effect"
  ) %>% as.list()
)

shiny::sliderInput(
  inputId = "scatterplot_range",
  label = "Scatterplot range:",
  min = 0,
  max = 50,
  value = 5
)

apply_filter <- function(de_wide) {
  if (main_effect_a_comparison_name %in% input$select_significant) {
    de_wide <- de_wide %>%
      dplyr::filter(get(glue::glue("padj_{main_effect_a_comparison_name}")) <= 0.05)
  }
  if (main_effect_b_comparison_name %in% input$select_significant) {
    de_wide <- de_wide %>%
      dplyr::filter(get(glue::glue("padj_{main_effect_b_comparison_name}")) <= 0.05)
  }
  if (source_effect_a_comparison_name %in% input$select_significant) {
    de_wide <- de_wide %>%
      dplyr::filter(get(glue::glue("padj_{source_effect_a_comparison_name}")) <= 0.05)
  }
  if (source_effect_b_comparison_name %in% input$select_significant) {
    de_wide <- de_wide %>%
      dplyr::filter(get(glue::glue("padj_{source_effect_b_comparison_name}")) <= 0.05)
  }
  if ("interaction_effect" %in% input$select_significant) {
    de_wide <- de_wide %>%
      dplyr::filter(get(glue::glue("padj_interaction_effect")) <= 0.05)
  }
  return(de_wide)
}

#' This is a super ugly hack for getting the clicked element of the data table
#' Normally this will only work in a shiny app where we can name the output
#' (see https://rstudio.github.io/DT/shiny.html). Here, we search the input
#' array for anything containing the name `rows_selected` and then look if
#' it contains not-null entries. If we find them, we return the index of the
#' selected DT entry. This will definitely lead to some unwanted behavior
#' but for now it's the only way I know for getting this to work without
#' migrating away from rmarkdown to a standard shiny app.
get_first_selected_in_dt <- function(input) {
  test <- names(input) %>%
    tibble::as_tibble() %>%
    dplyr::filter(stringr::str_detect(value, "rows_selected")) %>%
    dplyr::pull()
  for (i in test) {
    if (!is.null(input[[i]])) {
      # print(input[[i]])
      return(input[[i]][1])
    }
  }
}

```

##

### Table

```{r datatable}

DT::renderDataTable({
  de_wide %>%
    rmyknife::attach_biomart(attributes = "description", ensembl_version = 100) %>%
    dplyr::select(ensembl_gene_id, external_gene_name, description, dplyr::everything()) %>%
    apply_filter() %>%
    rmyknife::dt_datatable()
})

```

### Main effects colored by interaction term

```{r plot}

shiny::renderPlot({
  de_wide %>%
    apply_filter() %>%
    ggplot2::ggplot(
      mapping = ggplot2::aes_string(
        x = glue::glue("log2FoldChange_{main_effect_a_comparison_name}"),
        y = glue::glue("log2FoldChange_{main_effect_b_comparison_name}"),
        color = "log2FoldChange_interaction_effect",
        label = "external_gene_name"
      )
    ) %>%
    fc_scatterplot(
      colour_lab = "FC interaction effect",
      title = "FC main effect coloured by FC interaction effect",
      point_alpha = 1,
      min_range = -input$scatterplot_range,
      max_range = input$scatterplot_range
    ) +
    ggplot2::geom_point(
      data = de_wide %>% dplyr::filter(gene_id == input$gene_id),
      color = "red",
      size = 10
    )
})
```

##

### Violin-plot of each experimental group

```{r plot-each-group}
# Create a tidy long format of counts
plot_dat <- dplyr::left_join(
  x = col_data %>%
    dplyr::mutate(group = glue::glue("{source}_{treatment}")) %>%
    dplyr::select(id, group),
  y = counts,
  by = c("id" = "sample")
) %>%
  # Filtr all genes where we do not get a gene name
  dplyr::filter(!is.na(external_gene_name)) %>%
  # Create a unique gene_id variable for filtering
  dplyr::mutate(
    gene_id = paste0(ensembl_gene_id, "_", external_gene_name)
  ) %>%
  # Attach p-value from interaction effect
  dplyr::left_join(
    de %>%
      tidyr::pivot_wider(
        names_from = comparison,
        values_from = c(padj, log2FoldChange)
      ) %>%
      dplyr::select(ensembl_gene_id, padj_interaction_effect),
    by = "ensembl_gene_id"
  )

shiny::renderPlot({
  plot_dat %>%
    dplyr::filter(gene_id %in% input$gene_id) %>%
    ggplot2::ggplot(
      mapping = ggplot2::aes(
        x = group,
        y = value
      )
    ) +
    ggplot2::geom_violin() +
    ggplot2::geom_jitter(width = 0.1) +
    ggplot2::ggtitle(input$gene_id)
})
```

### Fold change and p-value for each comparison

```{r}
shiny::renderPlot({
  p1 <- de %>%
    dplyr::filter(gene_id %in% input$gene_id) %>%
    ggplot2::ggplot(
      mapping = ggplot2::aes(
        x = padj,
        y = comparison
      )
    ) +
#     ggplot2::geom_violin() +
    ggplot2::geom_point() +
    ggplot2::geom_vline(xintercept = 0.05, linetype = "dashed")
  
  p2 <- de %>%
    dplyr::filter(gene_id %in% input$gene_id) %>%
    ggplot2::ggplot(
      mapping = ggplot2::aes(
        x = log2FoldChange,
        y = comparison
      )
    ) +
    ggplot2::geom_point() +
    ggplot2::geom_vline(xintercept = 0)
    # Create title
    title <- cowplot::ggdraw() +
      cowplot::draw_label(
        input$gene_id,
        x = 0,
        hjust = 0
      )
    cowplot::plot_grid(
      title, p1, p2,
      ncol = 1,
      # rel_heights values control vertical title margins
      rel_heights = c(0.1, 1, 1)
    )
})
```