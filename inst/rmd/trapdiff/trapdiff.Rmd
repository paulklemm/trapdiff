---
title: "Trapdiff"
output:
  html_document:
    toc: no
    toc_float: no
    code_folding: hide
    fig_height: 5
    fig_width: 10
params:
  path_out: "./"
  path_config_json: ""
  save_figures: TRUE
  counts: ""
  ensembl_version: 99
---

```{r setup, results = "hide", message = FALSE, warning = FALSE}

library(magrittr)
suppressWarnings(library(rmyknife))

# Put params into separate object because sometimes params
# get's inaccessible when developing with xaringan
rmd_params <- params

# https://stackoverflow.com/questions/27992239/knitr-include-figures-in-report-and-output-figures-to-separate-files#comment71370705_27996644
if (rmd_params$save_figures) {
  knitr::opts_chunk$set(
    dev = c("png", "pdf"),
    fig.path = file.path(
      rmd_params$path_out,
      # Attach trailing '/'
      paste0("figures", .Platform$file.sep)
    )
  )
}
```

## {.tabset}

### Quality Control

#### Configuration

<details>
<summary>Show configuration</summary>

```{r show-run-config, paged.print = TRUE}
# Print settings as table
print_params <- rmd_params
print_params$counts <- "not displayed"
tibble::tibble(
  name = names(print_params),
  setting = print_params[names(print_params)]
) %>%
  knitr::kable()
```

```{r import-settings}

#' Get col_data for DESeq2 from JSON config
#' @param path_config_json Path to JSON configuration
#' @return col_data tibble
#' @export
#' @import purrr magrittr jsonlite dplyr forcats
get_coldata <- function(path_config_json) {
  # path_config_json <- rmd_params$path_config_json
  settings <- jsonlite::read_json(path_config_json)
  # Iterate over group names and create treatment column
  col_data_treatment <- dplyr::bind_rows(
    settings$treatment %>%
      # Iterate over all treatment names
      names() %>%
      purrr::map(function(group_name) {
        # Create tibble for treatment and it's samples
        tibble::tibble(
          treatment = group_name,
          sample_name = settings$treatment[group_name] %>% unlist()
        ) %>% return()
      })
  )
  # Attach IP/Input to col_data
  col_data_source <- dplyr::bind_rows(
    settings$source %>%
      names() %>%
      purrr::map(function(group_name) {
        tibble::tibble(
          source = group_name,
          sample_name = settings$source[group_name] %>% unlist()
        ) %>% return()
      })
  )
  # Join col_data source and treatment
  col_data <- dplyr::left_join(
    x = col_data_source,
    y = col_data_treatment,
    by = "sample_name"
  )
  # Get the proper factor levels of treatment and source in col_data
  treatment_fct_levels <- unlist(settings$treatment_comparison)
  source_fct_levels <- unlist(settings$source_comparison)
  col_data <-
    col_data %>%
    dplyr::mutate(
      treatment = forcats::as_factor(treatment) %>%
        forcats::fct_relevel(treatment_fct_levels),
      source = forcats::as_factor(source) %>%
        forcats::fct_relevel(source_fct_levels),
    )
  return(col_data)
}

# The order in coldata must be the same as in counts
# We achieve this by joining based on the id in counts
col_data <- tibble::tibble(
  id = rmd_params$counts %>%
    dplyr::select(-ensembl_gene_id) %>%
    # Get column names
    colnames()
) %>%
  dplyr::left_join(
    get_coldata(rmd_params$path_config_json),
    by = c("id" = "sample_name")
  )

```

```{r check-undefined-samples}

# Check if we have samples in count table that we do not have a treatment for
undefined_samples <- col_data %>%
  dplyr::filter(
    is.na(treatment) | is.na(source)
  )

# Print undefined samples if there are any
if (nrow(undefined_samples) > 0) {
  warning("We remove the following sample(s) because they were not assigned to a treatment/source group in the JSON config.")
  print(undefined_samples$id)
}

# Remove undefined samples from count matrix
counts <- rmd_params$counts
undefined_samples$id %>%
  purrr::walk(function(na_sample) {
    counts <<- counts %>%
      dplyr::select(-dplyr::contains(na_sample))
  })

# Remove undefined samples from col_data
col_data <- col_data %>%
  dplyr::filter(!is.na(treatment) & !is.na(source))

# Convert counts to integer to comply with DEseq2 standards
counts %<>%
  dplyr::mutate_if(is.double, round) %>%
  dplyr::mutate_if(is.double, as.integer)

```

The head of the counts table looks as follows

```{r print_top_entries}

counts %>%
  head() %>%
  rmarkdown::paged_table()
```

The sample group assignment table is defined as follows:

```{r print_design_table}

knitr::kable(col_data)

```

</details>

#### Run DESeq2

<details>
<summary>Show DESeq2 messages</summary>

```{r run-deseq2, cache = TRUE}

deseq_data <- DESeq2::DESeqDataSetFromMatrix(
  countData = counts %>% as.data.frame(),
  colData = col_data,
  design = ~ source + treatment + source:treatment,
  tidy = TRUE
)

deseq_result <- DESeq2::DESeq(deseq_data)
```

</details>

#### Principal Component Analysis

The **P**rincipal **C**omponent **A**nalysis (PCA) shows which samples are similar on a genomic level.
We want our experimental groups to cluster.
If they do not cluster, the variance between the groups is too low or the variance within the groups is too low.
This yields less differentially expressed genes.

```{r plot-pca}

#' PCA plot for quality control
#' @param dat data frame containing the columns `PC1`, `PC2`, `name` and `group`
#' @param title Additional information to put into the plot title
#' @return ggplot2 object of PCA plot
#' @import ggplot2 magrittr ggrepel
pca_plot <- function(dat, title = "") {
  dat %>%
    ggplot2::ggplot(ggplot2::aes(x = PC1, y = PC2, label = name, colour = group)) +
    ggplot2::geom_point() +
    ggplot2::ggtitle(paste0("PCA ", title)) +
    ggplot2::xlab(paste0("Principal Component 1 (", round(attr(dat, "percentVar")[1] * 100), "% variance explained)")) +
    ggplot2::ylab(paste0("Principal Component 2 (", round(attr(dat, "percentVar")[2] * 100), "% variance explained)")) +
    ggplot2::theme_minimal() +
    ggrepel::geom_text_repel()
}

pca_data <- DESeq2::plotPCA(
  DESeq2::vst(deseq_result, blind = FALSE),
  intgroup = "treatment",
  returnData = TRUE
) %>%
  # Attach source variable to PCA data for filtering
  dplyr::left_join(
    x = .,
    y = col_data %>% dplyr::select(id, source),
    by = c("name" = "id")
  )
# PCA plot of all samples
pca_plot(pca_data, "All samples")

# PCA for each source level
pca_data$source %>%
  levels() %>%
  purrr::walk(function(source_level) {
    pca_data %>%
      dplyr::filter(source == source_level) %>%
      pca_plot(paste0(source_level, " samples")) %>%
      print()
  })
```

### Differentially Expressed (DE) Genes

```{r get-contrasts}
# This works at the moment only for two treatment groups
## Main effect HFD vs NCD in IP
main_effect_ip <- DESeq2::results(
  object = deseq_result,
  contrast = c("treatment", col_data$treatment %>% levels())
) %>%
  rmyknife::deseq2_result_to_tibble()

# Main Effect HFD vs NCD in Input
main_effect_input <-
  DESeq2::results(
    object = deseq_result,
    contrast = list(DESeq2::resultsNames(deseq_result)[3:4])
  ) %>%
  rmyknife::deseq2_result_to_tibble() %>%
  # This effect needs to be inverted
  dplyr::mutate(log2FoldChange = log2FoldChange * -1)

interaction_effect <-
  DESeq2::results(
    object = deseq_result,
    contrast = list(DESeq2::resultsNames(deseq_result)[4])
  ) %>%
  rmyknife::deseq2_result_to_tibble()

select_join <- function(dat) {
  dplyr::select(dat, ensembl_gene_id, log2FoldChange, padj)
}

# Create a big data frame containing all comparisons of interest
de <- dplyr::bind_rows(
  main_effect_ip %>%
    select_join() %>%
    dplyr::mutate(comparison = "main_effect_ip"),
  main_effect_input %>%
    select_join() %>%
    dplyr::mutate(comparison = "main_effect_input"),
  interaction_effect %>%
    select_join() %>%
    dplyr::mutate(comparison = "interaction_effect"),
) %>%
  # Attach variable name
  rmyknife::attach_biomart(
    attributes = "external_gene_name",
    ensembl_version = rmd_params$ensembl_version,
    verbose = FALSE
  )

# de <- dplyr::left_join(
#   x = main_effect_ip %>% select_join(),
#   y = main_effect_input %>% select_join(),
#   by = "ensembl_gene_id",
#   suffix = c(".main_ip", ".main_input")
# ) %>%
#   dplyr::left_join(
#     y = interaction_effect %>%
#       select_join() %>%
#       dplyr::rename(
#         log2FoldChange.interaction = log2FoldChange,
#         padj.interaction = padj
#       ),
#     by = "ensembl_gene_id"
#   )
```

<details>
<summary>Plots per gene</summary>

```{r violin-plot}
violin_plot <- function(dat) {
  ggplot2::ggplot(
    data = dat,
    mapping = ggplot2::aes(
      x = group,
      y = value
    )
  ) +
    ggplot2::geom_point(position = "jitter")
}

# Create a tidy long format of counts
plot_dat <- dplyr::left_join(
  x = col_data %>%
    dplyr::mutate(group = glue::glue("{source}_{treatment}")) %>%
    dplyr::select(id, group),
  y = rmd_params$counts %>%
    tidyr::pivot_longer(cols = -ensembl_gene_id, names_to = "sample") %>%
    # Attach variable name
    rmyknife::attach_biomart(
      attributes = "external_gene_name",
      ensembl_version = rmd_params$ensembl_version,
      verbose = FALSE
    ),
  by = c("id" = "sample")
) %>%
  # Filtr all genes where we do not get a gene name
  dplyr::filter(!is.na(external_gene_name)) %>%
  # Create a unique gene_id variable for filtering
  dplyr::mutate(
    gene_id = paste0(ensembl_gene_id, "_", external_gene_name)
  ) %>%
  # Attach p-value from interaction effect
  dplyr::left_join(
    de %>%
      tidyr::pivot_wider(names_from = comparison, values_from = c(padj, log2FoldChange)) %>%
      dplyr::select(ensembl_gene_id, padj_interaction_effect),
    by = "ensembl_gene_id"
  ) %>%
  # Filter only for genes with significant interaction effect
  dplyr::filter(padj_interaction_effect <= 0.05) %>%
  dplyr::arrange(padj_interaction_effect)

plot_dat_sd <- plot_dat %>% crosstalk::SharedData$new(~gene_id, group = "Choose a gene")
crosstalk::filter_select(
  id = "gene",
  label = "Select Gene",
  sharedData = plot_dat_sd,
  group = ~gene_id,
  multiple = FALSE
)
```

</details>

<details>
<summary>Filter Result</summary>

```{r barplot}

plot_dat_sd %>%
  violin_plot() %>%
  plotly::ggplotly(dynamicTicks = TRUE)

```

</details>

#### DE-Plot

```{r de-plot}
de %>%
  tidyr::pivot_wider(names_from = comparison, values_from = c(padj, log2FoldChange)) %>%
  ggplot2::ggplot(
    mapping = ggplot2::aes(
      x = log2FoldChange_main_effect_ip,
      y = log2FoldChange_main_effect_input,
      color = log2FoldChange_interaction_effect,
      shape = padj_interaction_effect <= 0.05
    )
  ) +
  ggplot2::geom_point() +
  ggplot2::scale_x_continuous(limits = c(-5, 5)) +
  ggplot2::scale_y_continuous(limits = c(-5, 5)) +
  # ggplot2::scale_size(trans = 'reverse') +
  ggplot2::scale_color_distiller(palette = "RdBu", type = "div", direction = -1, limits = c(-5, 5)) +
  ggplot2::theme_minimal()
```

Let's check the DE genes for each effect.

```{r de-summary-table, warning = FALSE, message = FALSE}

de %>%
  dplyr::mutate(
    sig_up_regulated = padj <= 0.05 & log2FoldChange > 0,
    sig_down_regulated = padj <= 0.05 & log2FoldChange < 0
  ) %>%
  dplyr::group_by(comparison) %>%
  dplyr::summarise(
    up_regulated = sum(sig_up_regulated, na.rm = TRUE),
    down_regulated = sum(sig_down_regulated, na.rm = TRUE),
  ) %>%
  rmarkdown::paged_table()

# tibble::tibble(
#   name = c("effect", "Up-regulated genes", "Down-regulated genes"),
#   val = c(
#     main_effect_HFD_NCD_IP_tib %>%
#       dplyr::filter(padj <= 0.05 & log2FoldChange > 0) %>%
#       nrow(),
#     main_effect_HFD_NCD_IP_tib %>%
#       dplyr::filter(padj <= 0.05 & log2FoldChange < 0) %>%
#       nrow()
#   )
# ) %>%
#   knitr::kable()

```

```{r interactive-scatterplot}
plot <- de %>%
  tidyr::pivot_wider(names_from = comparison, values_from = c(padj, log2FoldChange)) %>%
  dplyr::filter(padj_interaction_effect <= 0.05) %>%
  # Some genes names are encoded multiple times by different ensembl gene ids
  # We therfore need to concatinate the two
  dplyr::mutate(
    gene_id = glue::glue("{ensembl_gene_id}_{external_gene_name}")
  ) %>%
  # The white space after the group is actually important. Otherwise the groups
  # of the two crosstalk objects will be linked. Brushing a gene in one will also
  # do so in the other plot
  crosstalk::SharedData$new(~gene_id, group = "Choose a gene ") %>%
  ggplot2::ggplot(
    mapping = ggplot2::aes(
      x = log2FoldChange_main_effect_ip,
      y = log2FoldChange_main_effect_input,
      color = log2FoldChange_interaction_effect
    )
  ) +
  ggplot2::geom_point() +
  ggplot2::scale_x_continuous(limits = c(-5, 5)) +
  ggplot2::scale_y_continuous(limits = c(-5, 5)) +
  ggplot2::labs(
    x = "fc_ip",
    y = "fc_input",
    colour = "fc_expression"
  ) +
  # ggplot2::scale_size(trans = 'reverse') +
  ggplot2::scale_color_distiller(
    palette = "RdBu",
    type = "div",
    direction = -1,
    limits = c(-5, 5)
  )

plot %>%
  plotly::ggplotly() %>%
  plotly::highlight(
    dynamic = FALSE,
    color = "red",
    selectize = TRUE
  )
```
