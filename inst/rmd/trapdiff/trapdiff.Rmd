---
title: "Trapdiff"
output:
  html_document:
    toc: no
    toc_float: no
    code_folding: hide
    fig_height: 5
    fig_width: 10
params:
  path_out: "./"
  path_config_json: ""
  save_figures: TRUE
  counts: ""
---

```{r setup, results = "hide", message = FALSE, warning = FALSE}

library(magrittr)
suppressWarnings(library(rmyknife))

# Put params into separate object because sometimes params
# get's inaccessible when developing with xaringan
rmd_params <- params

# https://stackoverflow.com/questions/27992239/knitr-include-figures-in-report-and-output-figures-to-separate-files#comment71370705_27996644
if (rmd_params$save_figures) {
  knitr::opts_chunk$set(
    dev = c("png", "pdf"),
    fig.path = file.path(
      rmd_params$path_out,
      # Attach trailing '/'
      paste0("figures", .Platform$file.sep)
    )
  )
}
```

## {.tabset}

### Overview & DESeq2 Run

#### Configuration

<details>
<summary>Show configuration</summary>

```{r show-run-config, paged.print = TRUE}
# Print settings as table
print_params <- rmd_params
print_params$counts <- "not displayed"
tibble::tibble(
  name = names(print_params),
  setting = print_params[names(print_params)]
) %>%
  knitr::kable()
```

```{r import-settings}

#' Get col_data for DESeq2 from JSON config
#' @param path_config_json Path to JSON configuration
#' @return col_data tibble
#' @export
#' @import purrr magrittr jsonlite dplyr forcats
get_coldata <- function(path_config_json) {
  # path_config_json <- rmd_params$path_config_json
  settings <- jsonlite::read_json(path_config_json)
  # Iterate over group names and create treatment column
  col_data_treatment <- dplyr::bind_rows(
    settings$treatment %>%
      # Iterate over all treatment names
      names() %>%
      purrr::map(function(group_name) {
        # Create tibble for treatment and it's samples
        tibble::tibble(
          treatment = group_name,
          sample_name = settings$treatment[group_name] %>% unlist()
        ) %>% return()
      })
  )
  # Attach IP/Input to col_data
  col_data_source <- dplyr::bind_rows(
    settings$source %>%
      names() %>%
      purrr::map(function(group_name) {
        tibble::tibble(
          source = group_name,
          sample_name = settings$source[group_name] %>% unlist()
        ) %>% return()
      })
  )
  # Join col_data source and treatment
  col_data <- dplyr::left_join(
    x = col_data_source,
    y = col_data_treatment,
    by = "sample_name"
  )
  # Get the proper factor levels of treatment and source in col_data
  treatment_fct_levels <- unlist(settings$treatment_comparison)
  source_fct_levels <- unlist(settings$source_comparison)
  col_data <-
    col_data %>%
    dplyr::mutate(
      treatment = forcats::as_factor(treatment) %>%
        forcats::fct_relevel(treatment_fct_levels),
      source = forcats::as_factor(source) %>%
        forcats::fct_relevel(source_fct_levels),
    )
  return(col_data)
}

# The order in coldata must be the same as in counts
# We achieve this by joining based on the id in counts
col_data <- tibble::tibble(
  id = rmd_params$counts %>%
    dplyr::select(-ensembl_gene_id) %>%
    # Get column names
    colnames()
) %>%
  dplyr::left_join(
    get_coldata(rmd_params$path_config_json),
    by = c("id" = "sample_name")
  )

```

```{r check-undefined-samples}

# Check if we have samples in count table that we do not have a treatment for
undefined_samples <- col_data %>%
  dplyr::filter(
    is.na(treatment) | is.na(source)
  )

# Print undefined samples if there are any
if (nrow(undefined_samples) > 0) {
  warning("We remove the following sample(s) because they were not assigned to a treatment/source group in the JSON config.")
  print(undefined_samples$id)
}

# Remove undefined samples from count matrix
counts <- rmd_params$counts
undefined_samples$id %>%
  purrr::walk(function(na_sample) {
    counts <<- counts %>%
      dplyr::select(-dplyr::contains(na_sample))
  })

# Remove undefined samples from col_data
col_data <- col_data %>%
  dplyr::filter(!is.na(treatment) & !is.na(source))

# Convert counts to integer to comply with DEseq2 standards
counts %<>%
  dplyr::mutate_if(is.double, round) %>%
  dplyr::mutate_if(is.double, as.integer)

```

The head of the counts table looks as follows

```{r print_top_entries}

counts %>%
  head() %>%
  rmarkdown::paged_table()
```

The sample group assignment table is defined as follows:

```{r print_design_table}

knitr::kable(col_data)

```

</details>

#### Run DESeq2

<details>
<summary>Show DESeq2 messages</summary>

```{r run-deseq2}

deseq_data <- DESeq2::DESeqDataSetFromMatrix(
  countData = counts %>% as.data.frame(),
  colData = col_data,
  design = ~ source + treatment + source:treatment,
  tidy = TRUE
)

deseq_result <- DESeq2::DESeq(deseq_data)
```

</details>