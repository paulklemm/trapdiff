---
title: "🧲 trapDiff"
output:
  html_document:
    toc: no
    toc_float: no
    code_folding: hide
    fig_height: 5
    fig_width: 10
params:
  path_out: "./"
  path_config_json: ""
  counts: ""
  tpms_min: 0
  padj_cutoff: 0.05
  ensembl_version: 102
  biotypes_filter: ""
  save_figures: TRUE
  deseq_split_size_factors: FALSE
  save_excel: FALSE
  save_rds: FALSE
  filter_regex: "^mt-"
  splits: !r c("treatment", "source")
---

```{r setup, results = "hide", message = FALSE, warning = FALSE}

library(magrittr)
library(rmyknife)
library(purrr)
library(furrr)

# Put params into separate object because sometimes params
# get's inaccessible when developing with xaringan
rmd_params <- params

# https://stackoverflow.com/questions/27992239/knitr-include-figures-in-report-and-output-figures-to-separate-files#comment71370705_27996644
if (rmd_params$save_figures) {
  knitr::opts_chunk$set(
    dev = c("png", "pdf"),
    fig.path = file.path(
      rmd_params$path_out,
      # Attach trailing '/'
      paste0("figures", .Platform$file.sep)
    )
  )
}

# Setup available processors for furrr
future::plan(
  future::multicore,
  workers = future::availableCores()
)

# Set Theme options
ggplot2::theme_set(
  ggplot2::theme_minimal(
    base_size = 12
    # base_family = "Open Sans"
  )
)
ggplot2::theme_update(
  axis.ticks = ggplot2::element_line(color = "grey92"),
  axis.ticks.length = ggplot2::unit(.5, "lines"),
  panel.grid.minor = ggplot2::element_blank(),
  legend.title = ggplot2::element_text(size = 12),
  legend.text = ggplot2::element_text(color = "grey30"),
  plot.title = ggplot2::element_text(size = 18, face = "bold"),
  plot.subtitle = ggplot2::element_text(size = 12, color = "grey30"),
  plot.caption = ggplot2::element_text(size = 9, margin = ggplot2::margin(t = 15)),
  plot.title.position = 'plot'
)
```

```{r functions}
#' Volcano plot
#' @param dat Frame containing log2FoldChange, padj, external_gene_name
#' @param min_padj Minimum adjusted p-value
#' @param min_log2fc Minimum log2FoldChange
#' @param plot_top_n How many top-regulated gene names should be rendered
#' @param title plot title
#' @export
#' @import ggplot2 magrittr ggrepel
plot_volcano <- function(dat, min_padj, min_log2fc, plot_top_n = 10, title = "") {
  dat %>%
    # Remove entries that cannot be drawn
    dplyr::filter(!is.na(padj) & !is.na(log2FoldChange)) %>%
    ggplot2::ggplot(
      mapping = ggplot2::aes(
        x = log2FoldChange,
        y = -log10(padj),
        color = ((padj <= min_padj & log2FoldChange >= min_log2fc) | (padj <= min_padj & log2FoldChange <= -min_log2fc)) %>% ifelse(., "significant", "not significant")
      )
    ) +
    ggplot2::geom_point(
      alpha = 0.3,
      size = 0.5
    ) +
    ggplot2::scale_color_manual(values = c("grey", "blue")) +
    ggplot2::xlab(expression(log[2](fc))) +
    ggplot2::ylab(expression(-log[10](adjusted ~ p ~ value))) +
    ggplot2::labs(colour = "Significance") +
    ggplot2::theme_minimal() +
    ggrepel::geom_text_repel(
      data = . %>%
        dplyr::arrange(padj) %>%
        head(plot_top_n),
      mapping = ggplot2::aes(label = external_gene_name),
      size = 3
    ) +
    ggplot2::geom_hline(
      yintercept = -log10(min_padj),
      linetype = "dotted"
    ) +
    ggplot2::geom_vline(
      xintercept = -min_log2fc,
      linetype = "dotted"
    ) +
    ggplot2::geom_vline(
      xintercept = min_log2fc,
      linetype = "dotted"
    ) +
    ggplot2::ggtitle(title)
}
```

**trapdiff** performs interaction term analysis of complex experimental setups, such as riboTRAP or bacTRAP data.

This document contains settings and logs for running this analysis and contains the result as spreadsheet.

Here is what you should do.

1. Check the PCA's if the samples cluster properly for your *source* and *treatment* condition.
2. Check your differentially expressed genes
3. Check the CPMs for the DE genes in the **CPM Gene Plots** section

Data dictionary for the output table (see DE genes).

| Column                              | Description                                                                                                                                                                                                                                          |
|-------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `gene_id`                           | [ensembl.org](https://www.ensembl.org/info/genome/stable_ids/index.html) gene stable ID and gene name                                                                                                                                                |
| `padj_x_y_z`                        | [DESeq2](https://doi.org/10.1186/s13059-014-0550-8) - Benjamini-Hochberg adjusted `pvalue`, adjustment for false discovery rate (FDR). Comparison of group `x` and `y` in condition `z`.                                                             |
| `padj_interaction_effect`           | [DESeq2](https://doi.org/10.1186/s13059-014-0550-8) - Benjamini-Hochberg adjusted `pvalue`, adjustment for false discovery rate (FDR). Value for `interaction effect`.                                                                               |
| `log2FoldChange_x_y_z`              | [DESeq2](https://doi.org/10.1186/s13059-014-0550-8) - effect size estimate between group `x` and `y` in condition `z`. A log2 fold change of 1.5 means the gene expression is increased by 2^1.5 = 2.82.. Comparison of group x vs y in condition z. |
| `log2FoldChange_interaction_effect` | [DESeq2](https://doi.org/10.1186/s13059-014-0550-8) - effect size estimate of the `interaction effect`.                                                                                                                                              |

## Trapdiff {.tabset}

### Analysis Run

#### Configuration

```{r show-run-config, paged.print = TRUE}
# Print settings as table
print_params <- rmd_params
rmyknife::print_params(print_params, omit = c("counts"))
```

<details>
<summary>DESeq2 Settings</summary>

```{r import-settings}

settings <- jsonlite::read_json(rmd_params$path_config_json)

#' Get col_data for DESeq2 from JSON config
#' @param settings Configurations object
#' @return col_data tibble
#' @export
#' @import purrr magrittr jsonlite dplyr forcats
get_coldata <- function(settings) {
  # path_config_json <- rmd_params$path_config_json
  # Iterate over group names and create treatment column
  col_data_treatment <- dplyr::bind_rows(
    settings$treatment %>%
      # Iterate over all treatment names
      names() %>%
      purrr::map(function(group_name) {
        # Create tibble for treatment and it's samples
        tibble::tibble(
          treatment = group_name,
          sample_name = settings$treatment[group_name] %>% unlist()
        ) %>% return()
      })
  )
  # Attach IP/Input to col_data
  col_data_source <- dplyr::bind_rows(
    settings$source %>%
      names() %>%
      purrr::map(function(group_name) {
        tibble::tibble(
          source = group_name,
          sample_name = settings$source[group_name] %>% unlist()
        ) %>% return()
      })
  )
  # Join col_data source and treatment
  col_data <- dplyr::left_join(
    x = col_data_source,
    y = col_data_treatment,
    by = "sample_name"
  )
  # Get the proper factor levels of treatment and source in col_data
  treatment_fct_levels <- unlist(settings$treatment_comparison)
  source_fct_levels <- unlist(settings$source_comparison)
  col_data <-
    col_data %>%
    dplyr::mutate(
      treatment = forcats::as_factor(treatment) %>%
        forcats::fct_relevel(treatment_fct_levels),
      source = forcats::as_factor(source) %>%
        forcats::fct_relevel(source_fct_levels),
    )
  return(col_data)
}

# The order in coldata must be the same as in counts
# We achieve this by joining based on the id in counts
col_data <- tibble::tibble(
  id = rmd_params$counts %>%
    dplyr::select(-ensembl_gene_id) %>%
    # Get column names
    colnames()
) %>%
  dplyr::left_join(
    get_coldata(settings),
    by = c("id" = "sample_name")
  )

```

```{r check-undefined-samples}

# Check if we have samples in count table that we do not have a treatment for
undefined_samples <- col_data %>%
  dplyr::filter(
    is.na(treatment) | is.na(source)
  )

# Print undefined samples if there are any
if (nrow(undefined_samples) > 0) {
  warning("We remove the following sample(s) because they were not assigned to a treatment/source group in the JSON config.")
  print(undefined_samples$id)
}

# Remove undefined samples from count matrix
counts <- rmd_params$counts
undefined_samples$id %>%
  purrr::walk(function(na_sample) {
    counts <<- counts %>%
      dplyr::select(-dplyr::contains(na_sample))
  })

# Remove undefined samples from col_data
col_data <- col_data %>%
  dplyr::filter(!is.na(treatment) & !is.na(source))

# Convert counts to integer to comply with DEseq2 standards
counts <- counts %>%
  dplyr::mutate_if(is.double, round) %>%
  dplyr::mutate_if(is.double, as.integer)

```

```{r remove-biotypes}

# Default report message.
remove_biotypes_report <- "We keep genes of all biotypes."
# Filter for biotypes of interest
if (!(rmd_params$biotypes_filter == "")) {
  counts <- counts %>%
    rmyknife::attach_biomart(
      attributes = "gene_biotype",
      ensembl_version = rmd_params$ensembl_version,
      verbose = FALSE
    ) %>%
    dplyr::filter(gene_biotype %in% rmd_params$biotypes_filter) %>%
    # Remove gene_biotype again
    dplyr::select(-gene_biotype)
  remove_biotypes_report <-
    glue::glue("We keep {counts %>% nrow()} genes that are of bioype(s) {rmd_params$biotypes_filter}")
}

```

```{r update-tpms}
# We need to calculate the TPMs based on the filtered counts matrix because the library size has changed
# See https://rna-seqblog.com/rpkm-fpkm-and-tpm-clearly-explained/
tpms <-
  counts %>%
  # Get gene length in KB
  rmyknife::attach_biomart(
    attributes = c("start_position", "end_position"),
    ensembl_version = rmd_params$ensembl_version,
    verbose = FALSE
  ) %>%
  dplyr::mutate(gene_length_kb = abs(end_position - start_position) / 1000) %>%
  dplyr::select(-start_position, -end_position) %>%
  # Make table long format for easier calculations
  tidyr::pivot_longer(-c(ensembl_gene_id, gene_length_kb), names_to = "sample", values_to = "count") %>%
  # Divide the read counts by the length of each gene in kilobases. This gives you reads per kilobase (RPK).
  dplyr::mutate(reads_per_kilobase = count / gene_length_kb) %>%
  # Count up all the RPK values in a sample and divide this number by 1,000,000. This is your “per million” scaling factor.
  dplyr::group_by(sample) %>%
  dplyr::mutate(rpk_scaling_factor = sum(reads_per_kilobase, na.rm = TRUE) / 1000000) %>%
  dplyr::ungroup() %>%
  # Divide the RPK values by the “per million” scaling factor. This gives you TPM.
  dplyr::mutate(tpm = reads_per_kilobase / rpk_scaling_factor) %>%
  # Make it a wide format again
  dplyr::select(ensembl_gene_id, sample, tpm) %>%
  tidyr::pivot_wider(names_from = sample, values_from = tpm)

```

`r remove_biotypes_report`

```{r remove-min-tpms}

# Get mean tpms for each experimental group
genes_satisfying_min_tpms <- tpms %>%
  # Make a long format to make computation easier
  tidyr::pivot_longer(
    cols = -ensembl_gene_id,
    names_to = "sample",
    values_to = "tpm"
  ) %>%
  dplyr::left_join(
    x = .,
    y = col_data %>%
      dplyr::mutate(experimental_group = glue::glue("{source}_{treatment}")) %>%
      dplyr::select(id, experimental_group),
    by = c("sample" = "id")
  ) %>%
  # Group by gene and experimental group
  dplyr::group_by(ensembl_gene_id, experimental_group) %>%
  # Get mean gene expression per experimental group
  dplyr::summarise(mean_tpm = mean(tpm, na.rm = TRUE)) %>%
  dplyr::ungroup() %>%
  # Filter for min_tpm
  dplyr::filter(mean_tpm >= rmd_params$tpms_min) %>%
  dplyr::select(ensembl_gene_id) %>%
  dplyr::distinct() %>%
  dplyr::pull()

genes_regex_filtered <-
  counts %>%
  rmyknife::attach_biomart(
    attributes = "external_gene_name",
    ensembl_version = rmd_params$ensembl_version
  ) %>%
  dplyr::filter(stringr::str_detect(external_gene_name, rmd_params$filter_regex)) %>%
  # dplyr::filter(stringr::str_detect(external_gene_name, "^mt-")) %>%
  dplyr::select(ensembl_gene_id) %>%
  dplyr::pull()

counts <-
  counts %>%
  # Update the counts based on the minimum TPM filter
  dplyr::filter(ensembl_gene_id %in% genes_satisfying_min_tpms) %>%
  # Remove genes that are manually filtered using the regex
  dplyr::filter(!(ensembl_gene_id %in% genes_regex_filtered))

```

We keep `r genes_satisfying_min_tpms %>% length()` genes where the mean of gene tpms in one of the groups (`r col_data %>% dplyr::mutate(experimental_group = glue::glue("{source}_{treatment}")) %>% dplyr::select(experimental_group) %>% dplyr::distinct() %>% dplyr::pull()`) a tpm of `r rmd_params$tpms_min` or more.

Additionally, we remove `r genes_regex_filtered %>% length()` genes manually with regex `r rmd_params$filter_regex`.

The head of the counts table looks as follows.

```{r print_top_entries}
counts %>%
  head() %>%
  rmarkdown::paged_table()
```

The head of the tpm table looks as follows. This table is only used for filtering gene minimum expression as well as for visualization later on.

```{r print_top_entries_tpms}
tpms %>%
  head() %>%
  rmarkdown::paged_table()
```

The sample group assignment table is defined as follows:

```{r print_design_table}
knitr::kable(col_data)
```

</details>

#### Run DESeq2

The design formula is `design = ~ source + treatment + source:treatment`.

The main effect is `treatment`, adjusting for `source` and the interaction between `source` and `treatment`.

```{r get-levels}
treatment_a <- col_data$treatment %>%
  levels() %>%
  .[1]
treatment_b <- col_data$treatment %>%
  levels() %>%
  .[2]
source_a <- col_data$source %>%
  levels() %>%
  .[1]
source_b <- col_data$source %>%
  levels() %>%
  .[2]

tibble::tibble(
  condition = c("a", "b"),
  treatment = c(treatment_a, treatment_b),
  source = c(source_a, source_b)
) %>%
  knitr::kable()
```

<details>
<summary>Show DESeq2 messages</summary>

```{r run-deseq2}

# Test size factor estimation individually by treatment (IP or Input)
col_data_treatment_a <- dplyr::filter(col_data, treatment %in% treatment_a[[1]])
col_data_treatment_b <- dplyr::filter(col_data, treatment %in% treatment_b[[1]])
col_data_source_a <- dplyr::filter(col_data, source %in% source_a[[1]])
col_data_source_b <- dplyr::filter(col_data, source %in% source_b[[1]])

#' Function splits col_data by split_column and runs DESeq2 separately to retreive size factors
#' @param counts Raw counts for use in DESeq2
#' @param split_column Either "source" or "treatment"
#' @param col_data col_data object that will be split based on split_column
#' @examples
#'   # If treatment encodes IP/Input, it will run DESeq2 on IP/Input samples separately
#'   get_size_factors(counts, split_column = "treatment", col_data = col_data)
get_size_factors <- function(counts, split_column, col_data) {
  # split_column <- "source"
  # split_column <- "treatment"
  sizefactors <-
    col_data[split_column][[1]] %>%
    levels() %>%
    # Get size factors for each level separately
    purrr::map(
      function(level) {
        # level <- "input"
        # level <- "fasted"
        # Filter col_data for the current level
        my_col_data <-
          col_data %>%
          dplyr::filter(get(!!split_column) == level)
        # Create DESeq2 object for current level
        DESeq2::DESeqDataSetFromMatrix(
          countData =
            counts %>%
              # Select columns of treatment condition
              dplyr::select(ensembl_gene_id, my_col_data$id) %>%
              as.data.frame(),
          colData = my_col_data,
          design = ~ 1,
          tidy = TRUE
        ) %>%
        # Extract size factors from DESeq2 model
        DESeq2::estimateSizeFactors() %>%
        .$sizeFactor %>%
        tibble::enframe(name = "id", value = "sizeFactor")
    }) %>%
    dplyr::bind_rows()
  # Left join with col_data to maintain the correct order
  col_data %>%
    dplyr::left_join(
      sizefactors,
      by = "id"
    ) %>%
    dplyr::select(id, sizeFactor)
}

#' Wrapper for size get_size_factors that checks how many split columns are provided
#' This allows to split columns based on both treatment and source variable if needed
#' @param counts Raw count table
#' @param split_columns Either "source", "treatment", or c("source", "treatment")
#' @param col_data col_data for DESeq2
get_size_factors_2 <- function(counts, split_columns, col_data) {
  # split_columns <- c("source", "treatment")
  if (length(split_columns) == 1) {
    get_size_factors(counts, split_columns, col_data) %>%
      return()
  } else if (length(split_columns) == 2) {
    # Iterate over first split column levels, filter col_data for it, and return the result
    first_split_column <- split_columns[1][[1]]
    second_split_column <- split_columns[2][[1]]
    sizefactors <-
      col_data[first_split_column][[1]] %>%
      levels() %>%
      purrr::map(
        function(split_column_level) {
          # split_column_level <- "fasted"
          # Get col_data filtered for split_column_level
          col_data_split <-
            col_data %>%
            dplyr::filter(get(!!first_split_column) == split_column_level)
          # Run size factor estimation only on this split column level
          get_size_factors(counts, second_split_column, col_data_split)
        }
      ) %>%
      dplyr::bind_rows()
    # Use same sorting as col_data
    col_data %>%
      dplyr::left_join(
        sizefactors,
        by = "id"
      ) %>%
      dplyr::select(id, sizeFactor) %>%
      return()
  } else (
    glue::glue("Invalid split variables, {split_columns}") %>%
      stop()
  )
}

size_factors_split <-
  get_size_factors_2(
    counts = counts,
    split_columns = rmd_params$splits,
    col_data = col_data
  )

#' Helper function that either runs DESeq2 step by step by spliting the sizeFactor estimation
#' using the split variables defined in the parameters.
#' Alternatively, it runs standard DESeq2.
deseq_helper <- function(deseq_dat, col_dat) {
  # col_dat <- col_data_source_a
  if (rmd_params$deseq_split_size_factors) {
    print("Run DESeq2 with split size factor estimation")
    # Now we run DESeq2 manually. See https://bioconductor.org/packages/release/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#wald-test-individual-steps
    deseq_dat %>%
      # DESeq2::estimateSizeFactors() %>%
      (function(dds) {
        # dds <- deseq_dat
        # Get size factors
        DESeq2::sizeFactors(dds) <-
          # Only select size factor ids required in col_dat
          col_dat %>%
          dplyr::left_join(size_factors_split, by = "id") %>%
          dplyr::select(id, sizeFactor) %>%
          tibble::deframe()
        return(dds)
      }) %>%
      DESeq2::estimateDispersions() %>%
      DESeq2::nbinomWaldTest() %>%
      return()
  } else {
    print("Run DESeq2 Standard without split size factor estimation")
    # This is the "old" call of DESeq2 that calculates size-factors on all samples
    DESeq2::DESeq(deseq_dat) %>%
      return()
  }
}

# Here we create the DESeq2 objects that are used to create the contrasts.
# We are using a DESeq2 object that contain treatment and source to be able to
# get the interaction effects from the model.
# Additionally, we create a DESeq2 model for source and treatment
# separately to not have the source or treatment levels interfering with the
# size factor estimation.
deseq_result <- DESeq2::DESeqDataSetFromMatrix(
  countData = counts %>% as.data.frame(),
  colData = col_data,
  design = ~ source + treatment + source:treatment,
  tidy = TRUE
) %>%
  deseq_helper(col_data)

# Standard DESeq2 models
deseq_source_effect_a <-
  DESeq2::DESeqDataSetFromMatrix(
  countData =
    counts %>%
      # Select columns of treatment condition
      dplyr::select(ensembl_gene_id, col_data_treatment_a$id) %>%
      as.data.frame(),
  colData = col_data_treatment_a,
  design = ~ source,
  tidy = TRUE
) %>%
  deseq_helper(col_data_treatment_a)

deseq_source_effect_b <-
  DESeq2::DESeqDataSetFromMatrix(
  countData =
    counts %>%
      # Select columns of treatment condition
      dplyr::select(ensembl_gene_id, col_data_treatment_b$id) %>%
      as.data.frame(),
  colData = col_data_treatment_b,
  design = ~ source,
  tidy = TRUE
) %>%
  deseq_helper(col_data_treatment_b)

deseq_main_effect_a <-
  DESeq2::DESeqDataSetFromMatrix(
  countData =
    counts %>%
      # Select columns of source condition
      dplyr::select(ensembl_gene_id, col_data_source_a$id) %>%
      as.data.frame(),
  colData = col_data_source_a,
  design = ~ treatment,
  tidy = TRUE
) %>%
  deseq_helper(col_data_source_a)

deseq_main_effect_b <-
  DESeq2::DESeqDataSetFromMatrix(
  countData =
    counts %>%
      # Select columns of source condition
      dplyr::select(ensembl_gene_id, col_data_source_b$id) %>%
      as.data.frame(),
  colData = col_data_source_b,
  design = ~ treatment,
  tidy = TRUE
) %>%
  deseq_helper(col_data_source_b)

# Create DESeq2 data for source groups separately to be able to
# plot the PCA for these groups individually
deseq_results_source <-
  col_data$source %>%
  levels() %>%
  purrr::map(
    function(source_level) {
      # source_level <- "ip"
      source_level_samples <-
        col_data %>%
        dplyr::filter(source == source_level) %>%
        .$id
      # Filter counts file only for samples of current level
      source_level_counts <-
        counts %>%
        dplyr::select(ensembl_gene_id, source_level_samples)
      # Create col_data only for current source level
      source_level_col_data <-
        dplyr::left_join(
          x = tibble::tibble(
            id = source_level_counts %>% dplyr::select(-ensembl_gene_id) %>% colnames()
          ),
          y = col_data,
          by = "id"
        )
      # Create DESeq2 object
      source_level_deseq_result <- DESeq2::DESeqDataSetFromMatrix(
        countData = source_level_counts %>% as.data.frame(),
        colData = source_level_col_data,
        design = ~ treatment,
        tidy = TRUE
      ) %>%
        DESeq2::DESeq()
      source_level_deseq_result %>%
        return()
    }
  )
# Set the names for the list of DESeq2 results
names(deseq_results_source) <-
  col_data$source %>%
  levels()

# Create DESeq2 data for treatment groups separately to be able to
# plot the PCA for these groups individually
deseq_results_treatment <-
  col_data$treatment %>%
  levels() %>%
  purrr::map(
    function(treatment_level) {
      # treatment_level <- "ip"
      treatment_level_samples <-
        col_data %>%
        dplyr::filter(treatment == treatment_level) %>%
        .$id
      # Filter counts file only for samples of current level
      treatment_level_counts <-
        counts %>%
        dplyr::select(ensembl_gene_id, treatment_level_samples)
      # Create col_data only for current treatment level
      treatment_level_col_data <-
        dplyr::left_join(
          x = tibble::tibble(
            id = treatment_level_counts %>% dplyr::select(-ensembl_gene_id) %>% colnames()
          ),
          y = col_data,
          by = "id"
        )
      # Create DESeq2 object
      treatment_level_deseq_result <- DESeq2::DESeqDataSetFromMatrix(
        countData = treatment_level_counts %>% as.data.frame(),
        colData = treatment_level_col_data,
        design = ~ source,
        tidy = TRUE
      ) %>%
        DESeq2::DESeq()
      treatment_level_deseq_result %>%
        return()
    }
  )
# Set the names for the list of DESeq2 results
names(deseq_results_treatment) <-
  col_data$treatment %>%
  levels()

```

</details>

### Principal Component Analysis

The **P**rincipal **C**omponent **A**nalysis (PCA) shows which samples are similar on a genomic level.
We want our experimental groups to cluster.
If they do not cluster, the variance between the groups is too low or the variance within the groups is too low.
This yields less differentially expressed genes.

```{r plot-pca}

#' PCA plot for quality control
#' @param dat data frame containing the columns `PC1`, `PC2`, `name` and `group`
#' @param title Additional information to put into the plot title
#' @return ggplot2 object of PCA plot
#' @import ggplot2 magrittr ggrepel
pca_plot <- function(dat, title = "") {
  dat %>%
    ggplot2::ggplot(ggplot2::aes(x = PC1, y = PC2, label = name, colour = group)) +
    ggplot2::geom_point() +
    ggplot2::ggtitle(glue::glue("PCA {title}")) +
    ggplot2::xlab(glue::glue("Principal Component 1 ({round(attr(dat, 'percentVar')[1] * 100)}% variance explained)")) +
    ggplot2::ylab(glue::glue("Principal Component 2 ({round(attr(dat, 'percentVar')[2] * 100)}% variance explained)")) +
    ggplot2::theme_minimal() +
    ggrepel::geom_text_repel()
}

pca_data <- DESeq2::plotPCA(
  DESeq2::vst(deseq_result, blind = FALSE),
  intgroup = "treatment",
  returnData = TRUE
) %>%
  # Attach source variable to PCA data for filtering
  dplyr::left_join(
    x = .,
    y = col_data %>% dplyr::select(id, source),
    by = c("name" = "id")
  )
# PCA plot of all samples
pca_plot(pca_data, "All samples")

# PCA for each source level
deseq_results_source %>%
  names() %>%
  purrr::walk(function(source_name) {
    # source_name <- "ip"
    deseq_result_source <- deseq_results_source[source_name][[1]]
    DESeq2::plotPCA(
      DESeq2::vst(deseq_result_source, blind = FALSE),
      intgroup = "treatment",
      returnData = TRUE
    ) %>%
      pca_plot(glue::glue("Source level {source_name}")) %>%
      print()
  })

# PCA for each treatment level
deseq_results_treatment %>%
  names() %>%
  purrr::walk(function(treatment_name) {
    # treatment_name <- "ip"
    deseq_result_treatment <- deseq_results_treatment[treatment_name][[1]]
    DESeq2::plotPCA(
      DESeq2::vst(deseq_result_treatment, blind = FALSE),
      intgroup = "source",
      returnData = TRUE
    ) %>%
      pca_plot(glue::glue("Treatment level {treatment_name}")) %>%
      print()
  })

```

```{r get-contrasts, message = FALSE}
# This works at the moment only for two treatment and source groups
main_effect_a <-
  DESeq2::results(
    object = deseq_main_effect_a,
    contrast = c("treatment", col_data$treatment %>% levels())
  ) %>%
  rmyknife::deseq2_result_to_tibble()

main_effect_b <-
  DESeq2::results(
    object = deseq_main_effect_b,
    contrast = c("treatment", col_data$treatment %>% levels())
  ) %>%
  rmyknife::deseq2_result_to_tibble()

interaction_effect <-
  DESeq2::results(
    object = deseq_result,
    contrast = list(DESeq2::resultsNames(deseq_result)[4])
  ) %>%
  rmyknife::deseq2_result_to_tibble()

source_effect_a <-
  DESeq2::results(
    object = deseq_source_effect_a,
    contrast = c("source", col_data$source %>% levels())
  ) %>%
  rmyknife::deseq2_result_to_tibble()

source_effect_b <-
  DESeq2::results(
    object = deseq_source_effect_b,
    contrast = c("source", col_data$source %>% levels())
  ) %>%
  rmyknife::deseq2_result_to_tibble()

select_join <- function(dat) {
  dplyr::select(dat, ensembl_gene_id, log2FoldChange, padj)
}

# Create a big data frame containing all comparisons of interest
main_effect_a_comparison_name <- glue::glue("{treatment_a}_{treatment_b}_{source_a}")
main_effect_b_comparison_name <- glue::glue("{treatment_a}_{treatment_b}_{source_b}")
source_effect_a_comparison_name <- glue::glue("{source_a}_{source_b}_{treatment_a}")
source_effect_b_comparison_name <- glue::glue("{source_a}_{source_b}_{treatment_b}")
de <- dplyr::bind_rows(
  main_effect_a %>%
    select_join() %>%
    dplyr::mutate(comparison = main_effect_a_comparison_name),
  main_effect_b %>%
    select_join() %>%
    dplyr::mutate(comparison = main_effect_b_comparison_name),
  interaction_effect %>%
    select_join() %>%
    dplyr::mutate(comparison = "interaction_effect"),
  source_effect_a %>%
    select_join() %>%
    dplyr::mutate(comparison = source_effect_a_comparison_name),
  source_effect_b %>%
    select_join() %>%
    dplyr::mutate(comparison = source_effect_b_comparison_name)
) %>%
  # Attach variable name
  rmyknife::attach_biomart(
    attributes = c("external_gene_name"),
    ensembl_version = rmd_params$ensembl_version,
    verbose = FALSE
  )

de_wide <- de %>%
  tidyr::pivot_wider(
    names_from = comparison,
    values_from = c(padj, log2FoldChange)
  )

# Calculate CPMs here before they are saved
cpms <-
  counts %>%
  tidyr::pivot_longer(-ensembl_gene_id, names_to = "sample", values_to = "count") %>%
  dplyr::left_join(col_data, by = c("sample" = "id")) %>%
  # Add total number of reads per sample
  dplyr::group_by(sample) %>%
  dplyr::mutate(total_sample_count = sum(count)) %>%
  dplyr::ungroup() %>%
  # Calculate CPM
  dplyr::mutate(cpm = (count / total_sample_count) * 1000000) %>%
  dplyr::select(-total_sample_count)

```

```{r save_result, message = FALSE}

if (rmd_params$save_rds) {
  # Save differentially expressed genes
  saveRDS(
    object = de,
    file = glue::glue("{rmd_params$path_out}/de.rds")
  )
  # Save DESeq2 objects
  list(
    list(name = "deseq_main_effect_b", dat = deseq_main_effect_b),
    list(name = "deseq_main_effect_a", dat = deseq_main_effect_a),
    list(name = "deseq_source_effect_b", dat = deseq_source_effect_b),
    list(name = "deseq_source_effect_a", dat = deseq_source_effect_a),
    list(name = "deseq_result", dat = deseq_result)
  ) %>%
    purrr::walk(function(deseq_dat) {
      saveRDS(
        object = deseq_dat$dat,
        file = glue::glue("{rmd_params$path_out}/{deseq_dat$name}.rds")
      )
    })
  # Save column data object
  saveRDS(
    object = col_data,
    file = glue::glue("{rmd_params$path_out}/col_data.rds")
  )
  # Save raw Salmon counts
  saveRDS(
    object = counts %>%
      tidyr::pivot_longer(cols = -ensembl_gene_id, names_to = "sample") %>%
      # Attach variable name
      rmyknife::attach_biomart(
        attributes = "external_gene_name",
        ensembl_version = rmd_params$ensembl_version,
        verbose = FALSE
      ),
    file = glue::glue("{rmd_params$path_out}/counts.rds")
  )
  # Save tpms
  saveRDS(
    object = tpms %>%
      tidyr::pivot_longer(cols = -ensembl_gene_id, names_to = "sample") %>%
      # Attach variable name
      rmyknife::attach_biomart(
        attributes = "external_gene_name",
        ensembl_version = rmd_params$ensembl_version,
        verbose = FALSE
      ),
    file = glue::glue("{rmd_params$path_out}/tpms.rds")
  )
  # Save cpms
  saveRDS(
    object =
      cpms %>%
      # Attach variable name
      rmyknife::attach_biomart(
        attributes = "external_gene_name",
        ensembl_version = rmd_params$ensembl_version,
        verbose = FALSE
      ) %>%
      dplyr::select(ensembl_gene_id, external_gene_name, cpm, dplyr::everything()),
    file = glue::glue("{rmd_params$path_out}/cpms.rds")
  )
}

if (rmd_params$save_excel) {
  rmyknife::write_xls(
    dat = de_wide,
    ExcelFileName = glue::glue("{rmd_params$path_out}/de.xlsx"),
    SheetNames = "trapDiff Output"
  )
}
```

### Differentially Expressed (DE) Genes

#### Debug plots

<details>
<summary>
Debug: Correlate CPM log2FoldChange with DESeq2 log2FoldChange
</summary>

When we compare IP vs Input, the tissues can vastly differ.
DESeq2, when calculating size factors, creates reference samples and uses these to normalize counts.
With vastly different samples, this can skew the analysis.
Trapdiff by default enables calculating size-factors for treatment variables `r treatment_a` and `r treatment_b` individually.
To check if that works correctly, we relate the fold-changes calculated by DESeq2 with fold-changes calculated on CPMs (gene counts normalized by library size).

We want to see plots that correlate and where the center crosses coordinate 0, 0.
Values far off from that indicate a problem.
```{r plot-cpmfc-deseq-fc, , warning = FALSE, message = FALSE}

# {treatment_a}_{treatment_b}_{source_a}
# Comparison
treatmenta_treatmentb_sourcea <-
  dplyr::left_join(
    x = de %>%
      dplyr::filter(comparison == glue::glue("{treatment_a}_{treatment_b}_{source_a}")),
    y = cpms %>%
      dplyr::filter(source == source_a) %>%
      dplyr::group_by(ensembl_gene_id, treatment) %>%
      dplyr::summarise(mean_cpm = mean(cpm)) %>%
      tidyr::pivot_wider(names_from = treatment, values_from = mean_cpm) %>%
      dplyr::mutate(cpm_log2FoldChange = log2(get(treatment_a) / get(treatment_b))) %>%
      dplyr::select(ensembl_gene_id, cpm_log2FoldChange),
    by = "ensembl_gene_id"
  )

# {treatment_a}_{treatment_b}_{source_b}
treatmenta_treatmentb_sourceb <-
  dplyr::left_join(
    x = de %>%
      dplyr::filter(comparison == glue::glue("{treatment_a}_{treatment_b}_{source_b}")),
    y = cpms %>%
      dplyr::filter(source == source_b) %>%
      dplyr::group_by(ensembl_gene_id, treatment) %>%
      dplyr::summarise(mean_cpm = mean(cpm)) %>%
      tidyr::pivot_wider(names_from = treatment, values_from = mean_cpm) %>%
      dplyr::mutate(cpm_log2FoldChange = log2(get(treatment_a) / get(treatment_b))) %>%
      dplyr::select(ensembl_gene_id, cpm_log2FoldChange),
    by = "ensembl_gene_id"
  )

# {source_a}_{source_b}_{treatment_a}
sourcea_sourceb_treatmenta <-
  dplyr::left_join(
    x = de %>%
      dplyr::filter(comparison == glue::glue("{source_a}_{source_b}_{treatment_a}")),
    y = cpms %>%
      dplyr::filter(treatment == treatment_a) %>%
      dplyr::group_by(ensembl_gene_id, source) %>%
      dplyr::summarise(mean_cpm = mean(cpm)) %>%
      tidyr::pivot_wider(names_from = source, values_from = mean_cpm) %>%
      dplyr::mutate(cpm_log2FoldChange = log2(get(source_a) / get(source_b))) %>%
      dplyr::select(ensembl_gene_id, cpm_log2FoldChange),
    by = "ensembl_gene_id"
  )

# {source_a}_{source_b}_{treatment_b}
sourcea_sourceb_treatmentb <-
  dplyr::left_join(
    x = de %>%
      dplyr::filter(comparison == glue::glue("{source_a}_{source_b}_{treatment_b}")),
    y = cpms %>%
      dplyr::filter(treatment == treatment_b) %>%
      dplyr::group_by(ensembl_gene_id, source) %>%
      dplyr::summarise(mean_cpm = mean(cpm)) %>%
      tidyr::pivot_wider(names_from = source, values_from = mean_cpm) %>%
      dplyr::mutate(cpm_log2FoldChange = log2(get(source_a) / get(source_b))) %>%
      dplyr::select(ensembl_gene_id, cpm_log2FoldChange),
    by = "ensembl_gene_id"
  )

#' Scatterplot for mapping log2FoldChange against CPM log2FoldChange
cpm_comparison_plot <- function(dat, title) {
  dat %>%
    dplyr::filter(!is.na(padj)) %>%
    ggplot2::ggplot(
    mapping = ggplot2::aes(
      x = log2FoldChange,
      y = cpm_log2FoldChange,
      color = padj <= rmd_params$padj_cutoff
    )
  ) +
    ggplot2::geom_point(
      # shape = ".",
      shape = 19,
      alpha = 0.3,
      size = 0.5
    ) +
    ggplot2::ggtitle(title) +
    ggplot2::geom_hline(
      yintercept = 0,
      linetype = "dotted"
    ) +
    ggplot2::geom_vline(
      xintercept = 0,
      linetype = "dotted"
    )
}

cpm_comparison_plot(treatmenta_treatmentb_sourcea, glue::glue(glue::glue("{treatment_a} vs {treatment_b} in {source_a}")))
cpm_comparison_plot(treatmenta_treatmentb_sourcea, glue::glue(glue::glue("{treatment_a} vs {treatment_b} in {source_a} (Zoom)"))) +
  ggplot2::xlim(-1, 1) +
  ggplot2::ylim(-1, 1)
cpm_comparison_plot(treatmenta_treatmentb_sourceb, glue::glue(glue::glue("{treatment_a} vs {treatment_b} in {source_b}")))
cpm_comparison_plot(treatmenta_treatmentb_sourceb, glue::glue(glue::glue("{treatment_a} vs {treatment_b} in {source_b} (Zoom)"))) +
  ggplot2::xlim(-1, 1) +
  ggplot2::ylim(-1, 1)
cpm_comparison_plot(sourcea_sourceb_treatmenta, glue::glue(glue::glue("{source_a}_{source_b}_{treatment_a}")))
cpm_comparison_plot(sourcea_sourceb_treatmenta, glue::glue(glue::glue("{source_a}_{source_b}_{treatment_a} (Zoom)"))) +
  ggplot2::xlim(-1, 1) +
  ggplot2::ylim(-1, 1)
cpm_comparison_plot(sourcea_sourceb_treatmentb, glue::glue(glue::glue("{source_a}_{source_b}_{treatment_b}")))
cpm_comparison_plot(sourcea_sourceb_treatmentb, glue::glue(glue::glue("{source_a}_{source_b}_{treatment_b} (Zoom)"))) +
  ggplot2::xlim(-1, 1) +
  ggplot2::ylim(-1, 1)
```

When we look at library size vs size factor, we want to see a correlation. If these values do not correlate, we might need to split and calculate the size factors separately by IP/Input or our experimental groups.

```{r lib-size-plot}

plot_size_factor <- function(dat, color_var) {
  ggplot2::ggplot(
    data = dat,
    mapping = ggplot2::aes_string(
      x = "size_factor",
      y = "library_size",
      color = color_var
    )
  ) +
    ggplot2::geom_point() +
    ggplot2::ggtitle(
      glue::glue("DESeq2 size factor against library size colored by {color_var}"),
      "There should be no shifts in this dataset, library size and size factor should correlate"
    )
}

deseq_result %>%
  # Make dataframe with size factors, library size and col_data
  (function(dat) {
    # dat <- deseq_result
    sizefactors <-
      dat %>%
      DESeq2::sizeFactors() %>%
      tibble::enframe(name = "id", value = "size_factor")
    library_sizes <-
      dat %>%
      DESeq2::counts() %>%
      tibble::as_tibble() %>%
      tidyr::pivot_longer(cols = dplyr::everything(), names_to = "id", values_to = "count") %>%
      dplyr::group_by(id) %>%
      dplyr::summarise(library_size = sum(count))
    # Join the two into one frame by id
    dplyr::left_join(sizefactors, library_sizes, by = "id") %>%
      # Join source and treatment
      dplyr::left_join(col_data, by = "id")
  }) %>%
  # Plot both colored by treatment and source
  (function(dat) {
    plot_size_factor(dat, "source") %>% print()
    plot_size_factor(dat, "treatment") %>% print()
    return()
  })
```

</details>

<details>
<summary>
Comparing IP/Input library-size normalized CPM values.
</summary>

```{r normalised-cpm-analysis, warning = FALSE, message = FALSE}

if (settings$normalization == "treatment") {
  normalization_variable <- "treatment"
  comparison_variable <- "source"
} else {
  normalization_variable <- "source"
  comparison_variable <- "treatment"
}
# Get group names
ip_variable <- settings[glue::glue("{normalization_variable}_comparison")][[1]][1][[1]]
in_variable <- settings[glue::glue("{normalization_variable}_comparison")][[1]][2][[1]]
comp_a_variable <- settings[glue::glue("{comparison_variable}_comparison")][[1]][1][[1]]
comp_b_variable <- settings[glue::glue("{comparison_variable}_comparison")][[1]][2][[1]]

# Get DESeq2 normalized CPMs
counts_normalized <-
  deseq_result %>%
  DESeq2::counts(normalized = TRUE) %>%
  rmyknife::deseq2_result_to_tibble() %>%
  tidyr::pivot_longer(-ensembl_gene_id, names_to = "sample", values_to = "count") %>%
  dplyr::mutate(sample_id = stringr::str_extract(sample, pattern = "(\\d)+$")) %>%
  # Attach col_data
  dplyr::left_join(col_data, by = c("sample" = "id")) %>%
  dplyr::select(-sample) %>%
  tidyr::pivot_wider(names_from = normalization_variable, values_from = count) %>%
  dplyr::mutate(count_norm = get(ip_variable) / get(in_variable)) %>%
  dplyr::select(ensembl_gene_id, comparison_variable, sample_id, count_norm) %>%
  dplyr::filter(!is.na(count_norm) & !is.infinite(count_norm))

# cpms_normalized <-
#   cpms %>%
#   # dplyr::filter(cpm > 0) %>%
#   dplyr::mutate(sample_id = stringr::str_extract(sample, pattern = "(\\d)+$")) %>%
#   dplyr::select(-count, -sample) %>%
#   #dplyr::group_by(ensembl_gene_id, sample_id, source) %>%
#   tidyr::pivot_wider(names_from = normalization_variable, values_from = cpm) %>%
#   dplyr::mutate(cpm_norm = get(ip_variable) / get(in_variable)) %>%
#   dplyr::select(ensembl_gene_id, comparison_variable, sample_id, cpm_norm) %>%
#   dplyr::filter(!is.na(cpm_norm) & !is.infinite(cpm_norm))

t_test_result <-
  # Iterate over all genes
  counts_normalized$ensembl_gene_id %>%
  unique() %>%
  # purrr::map(function(gene_id) {
  furrr::future_map(function(gene_id) {
    # Check if we get enough samples
    counts_normalized_of_gene <-
      counts_normalized %>%
      dplyr::filter(ensembl_gene_id == gene_id) %>%
      dplyr::filter(!is.infinite(count_norm))
    min_valid_samples <-
      counts_normalized_of_gene %>%
      dplyr::count(get(comparison_variable))
    # If we do not have enough valid samples, return
    if (nrow(min_valid_samples) < 2 | min(min_valid_samples$n) < 2) { return() }
    # Get Fold-change
    l2fc <-
      counts_normalized_of_gene %>%
      dplyr::group_by(get(comparison_variable)) %>%
      dplyr::summarise(mean_count_norm = mean(count_norm), .groups = "drop_last") %>%
      tidyr::pivot_wider(names_from = `get(comparison_variable)`, values_from = mean_count_norm) %>%
      dplyr::mutate(fc = log2(get(comp_a_variable) / get(comp_b_variable))) %>%
      .$fc
    # Perform t-test
    counts_normalized_of_gene %>%
      infer::t_test(
        response = count_norm,
        explanatory = source,
        order = c(settings$source_comparison[[1]], settings$source_comparison[[2]])
      ) %>%
      # Attach gene id to be able to tell later on
      dplyr::mutate(
        ensembl_gene_id = gene_id,
        log2FoldChange = l2fc
      ) %>%
      return()
  }) %>%
  dplyr::bind_rows() %>%
  # Attach external gene name
  rmyknife::attach_biomart(
    attributes = "external_gene_name",
    ensembl_version = rmd_params$ensembl_version,
    verbose = FALSE
  )

if (rmd_params$save_rds) {
  # Save t-test
  t_test_result %>%
    dplyr::select(ensembl_gene_id, external_gene_name, dplyr::everything()) %>%
    readr::write_csv(file = glue::glue("{rmd_params$path_out}/ratio_t_test.csv.gz"))
  # DESeq2 normalized counts
  deseq_result %>%
    DESeq2::counts(normalized = TRUE) %>%
    rmyknife::deseq2_result_to_tibble() %>%
    tidyr::pivot_longer(-ensembl_gene_id, names_to = "sample", values_to = "count") %>%
    dplyr::mutate(sample_id = stringr::str_extract(sample, pattern = "(\\d)+$")) %>%
    # Attach col_data
    dplyr::left_join(col_data, by = c("sample" = "id")) %>%
    # Attach external_gene_name
    rmyknife::attach_biomart(attributes = "external_gene_name", ensembl_version = rmd_params$ensembl_version) %>%
    readr::write_csv(file = glue::glue("{rmd_params$path_out}/deseq_normalized_counts.csv.gz"))
  # Ratio counts
  counts_normalized %>%
    readr::write_csv(file = glue::glue("{rmd_params$path_out}/ratio_counts.csv.gz"))
}

```

```{r print-t-test, warning = FALSE, mesage = FALSE}
t_test_result %>%
  dplyr::rename(padj = p_value) %>%
  plot_volcano(
    min_padj = rmd_params$padj_cutoff,
    min_log2fc = 0,
    plot_top_n = 10,
    title = glue::glue("Fold-changes derived from library-size normalized counts compared using t-test ({comp_a_variable} vs {comp_b_variable})")
  ) +
    ggplot2::ylab(expression(-log[10](p ~ value)))

dplyr::left_join(
  x = t_test_result,
  # Get wide format of normalized counts
  y = counts_normalized %>%
    dplyr::mutate(sample = glue::glue("{source}_{sample_id}")) %>%
    dplyr::select(ensembl_gene_id, sample, count_norm) %>%
    tidyr::pivot_wider(names_from = sample, values_from = count_norm),
  by = "ensembl_gene_id"
) %>%
  dplyr::select(ensembl_gene_id, external_gene_name, dplyr::everything()) %>%
  rmyknife::dt_datatable()
```

Click on `Code` above to display the DE genes and normalized count values for this comparison.

```{r tpm-de-summary}
t_test_result %>%
  dplyr::mutate(
    sig_up_regulated = p_value <= rmd_params$padj_cutoff & log2FoldChange > 0,
    sig_down_regulated = p_value <= rmd_params$padj_cutoff & log2FoldChange < 0
  ) %>%
  dplyr::summarise(
    sig_up_regulated = sum(sig_up_regulated, na.rm = TRUE),
    sig_down_regulated = sum(sig_down_regulated, na.rm = TRUE),
  ) %>%
  knitr::kable()
```

Plotting the fold-change comparing the IPs vs fold-change of normalized counts.

```{r plot-foldchanges, warning = FALSE, message = FALSE}
foldchange_comparison <-
  dplyr::left_join(
    x = de %>%
      dplyr::filter(comparison == source_effect_a_comparison_name) %>%
      dplyr::select(ensembl_gene_id, log2FoldChange, padj, external_gene_name),
    y = t_test_result %>%
      dplyr::select(ensembl_gene_id, log2FoldChange, p_value),
    by = "ensembl_gene_id",
    suffix = c("_deseq", "_count")
  ) %>%
  # Attach significant variable for plotting
  dplyr::mutate(
    significant = ifelse(
      padj <= rmd_params$padj_cutoff & p_value <= rmd_params$padj_cutoff, "both", ifelse(
      padj > rmd_params$padj_cutoff & p_value <= rmd_params$padj_cutoff, "Only normalized", ifelse(
      padj <= rmd_params$padj_cutoff & p_value > rmd_params$padj_cutoff, "Only IPs",
      "none"
    )))
  ) %>%
  dplyr::mutate(
    significant = forcats::fct_relevel(significant, "none", "both", "Only IPs", "Only normalized")
  )

foldchange_comparison %>%
  dplyr::count(significant) %>%
  knitr::kable()

foldchange_comparison %>%
  dplyr::filter(!is.na(significant)) %>%
  ggplot2::ggplot(
    mapping = ggplot2::aes(
      x = log2FoldChange_deseq,
      y = log2FoldChange_count,
      color = significant
    )
  ) +
    ggplot2::geom_point(
      alpha = 0.3,
      size = 1
    ) +
    ggplot2::scale_color_manual(values = c("grey", "blue", "orange", "green")) +
    ggplot2::xlab(expression(log[2](fc ~ DESeq2 ~ IPs))) +
    ggplot2::ylab(expression(log[2](fc ~ normalized ~ counts ~ ttest))) +
    ggplot2::labs(colour = "Significance") +
    ggplot2::theme_minimal() +
    ggplot2::ggtitle(glue::glue("IP-only comparison fold-change vs normalized count foldchanges ({comp_a_variable} vs {comp_b_variable})"))

foldchange_comparison %>%
  dplyr::select(ensembl_gene_id, external_gene_name, dplyr::everything()) %>%
  rmyknife::dt_datatable()
```

Click on `Code` above to display the DE genes and normalized COUNT values for this comparison.

</details>

#### DE genes table

Let's check the DE genes for each effect (`r nrow(counts)` genes left in the analysis after initial filtering, see "Analysis run" section).

```{r de-summary-table, warning = FALSE, message = FALSE}
de %>%
  dplyr::mutate(
    sig_up_regulated = padj <= rmd_params$padj_cutoff & log2FoldChange > 0,
    sig_down_regulated = padj <= rmd_params$padj_cutoff & log2FoldChange < 0
  ) %>%
  dplyr::group_by(comparison) %>%
  dplyr::summarise(
    up_regulated = sum(sig_up_regulated, na.rm = TRUE),
    down_regulated = sum(sig_down_regulated, na.rm = TRUE),
  ) %>%
  gt::gt() %>%
  gt::tab_header(
    title = "Differentially expressed genes per comparison"
  )
```

#### DE genes table

Download the table in a format of your choosing.

```{r datatable, warning = FALSE}
de_wide %>%
  dplyr::mutate(
    gene_id = paste0(ensembl_gene_id, "_", external_gene_name)
  ) %>%
  dplyr::select(-ensembl_gene_id, -external_gene_name) %>%
  dplyr::select(gene_id, dplyr::everything()) %>%
  # Round all values to 4 decimals
  # dplyr::mutate_if(is.numeric, round, 4) %>%
  crosstalk::SharedData$new(~gene_id, group = "Choose a gene") %>%
  rmyknife::dt_datatable()
```

#### Volcano Plots for each comparison

`x_y_z` is read as comparison of group `x` and `y` in condition `z`.

```{r volcanos}
de$comparison %>%
  unique() %>%
  purrr::walk(function(current_comparison) {
    de %>%
      dplyr::filter(comparison == current_comparison) %>%
      plot_volcano(
        min_padj = rmd_params$padj_cutoff,
        min_log2fc = 0,
        title = current_comparison
      ) %>%
      print()
  })
```

### CPM Gene Plots

Select genes of interest in this table to plot their CPM expression values.
CPM values are normalized by library size, so for a gene we compare the counts between experimental conditions.

Because of a technically limitation, please first select a gene of interest here and then open the plot.
Otherwise this will drastically slow down your browser.

```{r prepare-gene-plot}
gene_plot <- function(dat) {
  ggplot2::ggplot(
    data = dat,
    mapping = ggplot2::aes(
      x = group,
      y = value
    )
  ) +
    ggplot2::geom_point(position = "jitter") +
    ggplot2::xlab("Experimental groups") +
    ggplot2::ylab("CPM")
}

# Create a tidy long format of tpms
plot_dat <- dplyr::left_join(
  x = col_data %>%
    dplyr::mutate(group = glue::glue("{source}_{treatment}")) %>%
    dplyr::select(id, group),
  y = cpms %>%
    dplyr::rename(value = cpm) %>%
    dplyr::select(ensembl_gene_id, sample, value) %>%
    # tpms %>%
    # tidyr::pivot_longer(cols = -ensembl_gene_id, names_to = "sample") %>%
    # Attach variable name
    rmyknife::attach_biomart(
      attributes = "external_gene_name",
      ensembl_version = rmd_params$ensembl_version,
      verbose = FALSE
    ),
  by = c("id" = "sample")
) %>%
  # Filtr all genes where we do not get a gene name
  dplyr::filter(!is.na(external_gene_name)) %>%
  # Create a unique gene_id variable for filtering
  dplyr::mutate(
    gene_id = paste0(ensembl_gene_id, "_", external_gene_name)
  ) %>%
  # Filter for any gene that is significant
  dplyr::filter(ensembl_gene_id %in% (de %>% dplyr::filter(padj <= rmd_params$padj_cutoff) %>% .$ensembl_gene_id))
  # # Attach p-value from interaction effect
  # dplyr::left_join(
  #   de %>%
  #     tidyr::pivot_wider(names_from = comparison, values_from = c(padj, log2FoldChange)) %>%
  #     dplyr::select(ensembl_gene_id, padj_interaction_effect),
  #   by = "ensembl_gene_id"
  # ) %>%
  # # Filter only for genes with significant interaction effect
  # dplyr::filter(padj_interaction_effect <= rmd_params$padj_cutoff) %>%
  # dplyr::filter(!is.na(padj_interaction_effect)) %>%
  # dplyr::arrange(padj_interaction_effect)

# We have to have at least one differentially expressed gene with the
# interaction term, otherwise we cannot create the SharedData object.
# If we have 0, then just use the original plot_dat
if (nrow(plot_dat) > 0) {
  # The white space after the group is actually important. Otherwise the groups
  # of the two crosstalk objects will be linked. Brushing a gene in one will also
  # do so in the other plot
  plot_dat_sd <- plot_dat %>% crosstalk::SharedData$new(~gene_id, group = "Choose a gene ")
  crosstalk::filter_select(
    id = "gene",
    label = "Select Gene",
    sharedData = plot_dat_sd,
    group = ~gene_id,
    multiple = FALSE
  )
} else {
  plot_dat_sd <- plot_dat
  de_sd <- de
}
```

<details>
<summary>Plot</summary>

```{r gene-plot}

plot_dat_sd %>%
  gene_plot() %>%
  plotly::ggplotly(dynamicTicks = TRUE)
```

</details>

```{r interactive-scatterplot}
fc_scatterplot <- function(
  ggplot_dat,
  colour_lab,
  title,
  x_lab = "fc_ip",
  y_lab = "fc_input",
  point_alpha = 0.3
) {
  ggplot_dat +
    ggplot2::geom_point(
      alpha = point_alpha
    ) +
    # ggplot2::scale_x_continuous(limits = c(-5, 5)) +
    # ggplot2::scale_y_continuous(limits = c(-5, 5)) +
    ggplot2::labs(
      # x = x_lab,
      # y = y_lab,
      colour = colour_lab
    ) +
    # ggplot2::scale_size(trans = 'reverse') +
    ggplot2::scale_color_distiller(palette = "RdBu", type = "div", direction = -1, limits = c(-5, 5)) +
    ggplot2::theme_minimal() +
    ggplot2::ggtitle(title)
}

interaction_term_count <-
  de_wide %>%
  dplyr::filter(padj_interaction_effect <= rmd_params$padj_cutoff) %>%
  nrow()

if (interaction_term_count > 0) {
  plot <- de_wide %>%
    dplyr::filter(padj_interaction_effect <= rmd_params$padj_cutoff) %>%
    # Some genes names are encoded multiple times by different ensembl gene ids
    # We therfore need to concatinate the two
    dplyr::mutate(
      gene_id = glue::glue("{ensembl_gene_id}_{external_gene_name}")
    ) %>%
    #  crosstalk::SharedData$new(~gene_id, group = "Choose a gene") %>%
    ggplot2::ggplot(
      mapping = ggplot2::aes_string(
        x = glue::glue("log2FoldChange_{main_effect_a_comparison_name}"),
        # x = "log2FoldChange_main_effect_in_source_a(ip_vs_input_in_il6)",
        y = glue::glue("log2FoldChange_{main_effect_b_comparison_name}"),
        # y = "log2FoldChange_main_effect_in_source_b(ip_vs_input_in_nacl)",
        color = "log2FoldChange_interaction_effect",
        label = "external_gene_name"
      )
    ) %>%
    fc_scatterplot(
      colour_lab = "FC interaction effect",
      title = "FC main effect coloured by FC interaction effect",
      point_alpha = 1
    )

  plot <- de_wide %>%
    dplyr::filter(padj_interaction_effect <= rmd_params$padj_cutoff) %>%
    # Some genes names are encoded multiple times by different ensembl gene ids
    # We therfore need to concatinate the two
    dplyr::mutate(
      gene_id = glue::glue("{ensembl_gene_id}_{external_gene_name}")
    ) %>%
    #  crosstalk::SharedData$new(~gene_id, group = "Choose a gene") %>%
    ggplot2::ggplot(
      mapping = ggplot2::aes_string(
        x = glue::glue("log2FoldChange_{main_effect_a_comparison_name}"),
        # x = "log2FoldChange_main_effect_in_source_a(ip_vs_input_in_il6)",
        y = glue::glue("log2FoldChange_{main_effect_b_comparison_name}"),
        # y = "log2FoldChange_main_effect_in_source_b(ip_vs_input_in_nacl)",
        color = "log2FoldChange_interaction_effect",
        label = "external_gene_name"
      )
    ) %>%
    fc_scatterplot(
      colour_lab = "FC interaction effect",
      title = "FC main effect coloured by FC interaction effect",
      point_alpha = 1
    )

  plot %>%
    plotly::ggplotly() %>%
    plotly::highlight(
      on = "plotly_click",
      off = "plotly_doubleclick",
      dynamic = FALSE,
      color = "red",
      selectize = TRUE
    )
} else {
  print("There are no genes differentially expressed with the interaction term.")
}
```

<details>
<summary>Supplementary plots</summary>

```{r de-plot}
de_wide %>%
  dplyr::mutate(interaction_significant = padj_interaction_effect <= rmd_params$padj_cutoff) %>%
  ggplot2::ggplot(
    mapping = ggplot2::aes_string(
      x = glue::glue("log2FoldChange_{main_effect_a_comparison_name}"),
      y = glue::glue("log2FoldChange_{main_effect_b_comparison_name}"),
      color = "log2FoldChange_interaction_effect",
      shape = "interaction_significant"
    )
  ) %>%
  fc_scatterplot(
    colour_lab = "fc_interaction",
    title = "FC main effect coloured by FC interaction effect",
    point_alpha = 1
  )
```

```{r additional-de-plot}
de_wide %>%
  # dplyr::filter(padj_source_effect_a <= rmd_params$padj_cutoff) %>%
  dplyr::filter(get(glue::glue("padj_{source_effect_a_comparison_name}")) <= rmd_params$padj_cutoff) %>%
  ggplot2::ggplot(
    mapping = ggplot2::aes_string(
      x = glue::glue("log2FoldChange_{main_effect_a_comparison_name}"),
      y = glue::glue("log2FoldChange_{main_effect_b_comparison_name}"),
      color = glue::glue("log2FoldChange_{source_effect_a_comparison_name}")
    )
  ) %>%
  fc_scatterplot(
    title = "FC Treatment in IP and Input with color of IP vs Input (in 'A' samples)",
    colour_lab = "FC source A"
  )

de_wide %>%
  dplyr::filter(get(glue::glue("padj_{source_effect_b_comparison_name}")) <= rmd_params$padj_cutoff) %>%
  ggplot2::ggplot(
    mapping = ggplot2::aes_string(
      x = glue::glue("log2FoldChange_{main_effect_a_comparison_name}"),
      y = glue::glue("log2FoldChange_{main_effect_b_comparison_name}"),
      color = glue::glue("log2FoldChange_{source_effect_b_comparison_name}")
    )
  ) %>%
  fc_scatterplot(
    title = "FC Treatment in IP and Input with color of IP vs Input (in 'B' samples)",
    colour_lab = "FC source B"
  )
```

Let's check how big the overlap between source and interaction is.

```{r overlap-source-interaction}
# de_wide %>%
#   dplyr::mutate(
#     source_a_regulated = padj_source_effect_a <= rmd_params$padj_cutoff,
#     source_b_regulated = padj_source_effect_b <= rmd_params$padj_cutoff,
#     interaction_regulated = padj_interaction_effect <= rmd_params$padj_cutoff
#   ) %>%
#   dplyr::select(source_a_regulated, source_b_regulated, interaction_regulated) %>%
#   # Replace NA values by "FALSE"
#   replace(is.na(.), FALSE) %>%
#   ComplexUpset::upset(intersect = colnames(.))
```

</details>
