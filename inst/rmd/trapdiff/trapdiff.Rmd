---
title: "Trapdiff"
output:
  html_document:
    toc: no
    toc_float: no
    code_folding: hide
    fig_height: 5
    fig_width: 10
params:
  path_out: "./"
  path_config_json: ""
  save_figures: TRUE
  counts: ""
  counts_min: 0
  ensembl_version: 99
  biotypes_filter: !r NA
  debug_cache: FALSE
  save_excel: FALSE
  save_rds: FALSE
---

```{r setup, results = "hide", message = FALSE, warning = FALSE}

library(magrittr)
suppressWarnings(library(rmyknife))

# Put params into separate object because sometimes params
# get's inaccessible when developing with xaringan
rmd_params <- params

# https://stackoverflow.com/questions/27992239/knitr-include-figures-in-report-and-output-figures-to-separate-files#comment71370705_27996644
if (rmd_params$save_figures) {
  knitr::opts_chunk$set(
    dev = c("png", "pdf"),
    fig.path = file.path(
      rmd_params$path_out,
      # Attach trailing '/'
      paste0("figures", .Platform$file.sep)
    )
  )
}
```

## {.tabset}

### Quality Control

#### Configuration

<details>
<summary>Show configuration</summary>

```{r show-run-config, paged.print = TRUE}
# Print settings as table
print_params <- rmd_params
print_params$counts <- "not displayed"
rmyknife::print_params(print_params)
```

```{r import-settings}

#' Get col_data for DESeq2 from JSON config
#' @param path_config_json Path to JSON configuration
#' @return col_data tibble
#' @export
#' @import purrr magrittr jsonlite dplyr forcats
get_coldata <- function(path_config_json) {
  # path_config_json <- rmd_params$path_config_json
  settings <- jsonlite::read_json(path_config_json)
  # Iterate over group names and create treatment column
  col_data_treatment <- dplyr::bind_rows(
    settings$treatment %>%
      # Iterate over all treatment names
      names() %>%
      purrr::map(function(group_name) {
        # Create tibble for treatment and it's samples
        tibble::tibble(
          treatment = group_name,
          sample_name = settings$treatment[group_name] %>% unlist()
        ) %>% return()
      })
  )
  # Attach IP/Input to col_data
  col_data_source <- dplyr::bind_rows(
    settings$source %>%
      names() %>%
      purrr::map(function(group_name) {
        tibble::tibble(
          source = group_name,
          sample_name = settings$source[group_name] %>% unlist()
        ) %>% return()
      })
  )
  # Join col_data source and treatment
  col_data <- dplyr::left_join(
    x = col_data_source,
    y = col_data_treatment,
    by = "sample_name"
  )
  # Get the proper factor levels of treatment and source in col_data
  treatment_fct_levels <- unlist(settings$treatment_comparison)
  source_fct_levels <- unlist(settings$source_comparison)
  col_data <-
    col_data %>%
    dplyr::mutate(
      treatment = forcats::as_factor(treatment) %>%
        forcats::fct_relevel(treatment_fct_levels),
      source = forcats::as_factor(source) %>%
        forcats::fct_relevel(source_fct_levels),
    )
  return(col_data)
}

# The order in coldata must be the same as in counts
# We achieve this by joining based on the id in counts
col_data <- tibble::tibble(
  id = rmd_params$counts %>%
    dplyr::select(-ensembl_gene_id) %>%
    # Get column names
    colnames()
) %>%
  dplyr::left_join(
    get_coldata(rmd_params$path_config_json),
    by = c("id" = "sample_name")
  )

```

```{r check-undefined-samples}

# Check if we have samples in count table that we do not have a treatment for
undefined_samples <- col_data %>%
  dplyr::filter(
    is.na(treatment) | is.na(source)
  )

# Print undefined samples if there are any
if (nrow(undefined_samples) > 0) {
  warning("We remove the following sample(s) because they were not assigned to a treatment/source group in the JSON config.")
  print(undefined_samples$id)
}

# Remove undefined samples from count matrix
counts <- rmd_params$counts
undefined_samples$id %>%
  purrr::walk(function(na_sample) {
    counts <<- counts %>%
      dplyr::select(-dplyr::contains(na_sample))
  })

# Remove undefined samples from col_data
col_data <- col_data %>%
  dplyr::filter(!is.na(treatment) & !is.na(source))

# Convert counts to integer to comply with DEseq2 standards
counts <- counts %>%
  dplyr::mutate_if(is.double, round) %>%
  dplyr::mutate_if(is.double, as.integer)

```

```{r remove-min-counts, cache = rmd_params$debug_cache}

# Get mean counts for each experimental group
genes_satisfying_min_counts <- counts %>%
  # Make a long format to make computation easier
  tidyr::pivot_longer(
    cols = -ensembl_gene_id,
    names_to = "sample",
    values_to = "count"
  ) %>%
  dplyr::left_join(
    x = .,
    y = col_data %>%
      dplyr::mutate(experimental_group = glue::glue("{source}_{treatment}")) %>%
      dplyr::select(id, experimental_group),
    by = c("sample" = "id")
  ) %>%
  # Group by gene and experimental group
  dplyr::group_by(ensembl_gene_id, experimental_group) %>%
  # Get mean gene expression per experimental group
  dplyr::summarise(mean_count = mean(count, na.rm = TRUE)) %>%
  dplyr::ungroup() %>%
  # Filter for min_count
  dplyr::filter(mean_count >= rmd_params$counts_min) %>%
  dplyr::select(ensembl_gene_id) %>%
  dplyr::distinct() %>%
  dplyr::pull()

counts <- counts %>%
  dplyr::filter(ensembl_gene_id %in% genes_satisfying_min_counts)

```

We keep `r genes_satisfying_min_counts %>% length()` genes where the mean of gene counts in one of the groups (`r col_data %>% dplyr::mutate(experimental_group = glue::glue("{source}_{treatment}")) %>% dplyr::select(experimental_group) %>% dplyr::distinct() %>% dplyr::pull()`) a count of `r rmd_params$counts_min` or more.

```{r remove-biotypes, cache = rmd_params$debug_cache}

# Default report message.
remove_biotypes_report <- "We keep genes of all biotypes."
# Filter for biotypes of interest
if (!is.na(rmd_params$biotypes_filter)) {
  counts <- counts %>%
    rmyknife::attach_biomart(
      attributes = "gene_biotype",
      ensembl_version = rmd_params$ensembl_version,
      verbose = FALSE
    ) %>%
    dplyr::filter(gene_biotype %in% rmd_params$biotypes_filter) %>%
    # Remove gene_biotype again
    dplyr::select(-gene_biotype)
  remove_biotypes_report <-
    glue::glue("We keep {counts %>% nrow()} genes that are of bioype(s) {rmd_params$biotypes_filter}")
}

```

`r remove_biotypes_report`

The head of the counts table looks as follows.

```{r print_top_entries}

counts %>%
  head() %>%
  rmarkdown::paged_table()
```

The sample group assignment table is defined as follows:

```{r print_design_table}

knitr::kable(col_data)

```

</details>

#### Run DESeq2

The design formula is `design = ~ source + treatment + source:treatment`.

The main effect is `treatment`, adjusting for `source` and the interaction between `source` and `treatment`.

```{r get-levels, cache = rmd_params$debug_cache}
treatment_a <- col_data$treatment %>%
  levels() %>%
  .[1]
treatment_b <- col_data$treatment %>%
  levels() %>%
  .[2]
source_a <- col_data$source %>%
  levels() %>%
  .[1]
source_b <- col_data$source %>%
  levels() %>%
  .[2]

tibble::tibble(
  condition = c("a", "b"),
  treatment = c(treatment_a, treatment_b),
  source = c(source_a, source_b)
) %>%
  knitr::kable()
```

<details>
<summary>Show DESeq2 messages</summary>

```{r run-deseq2, cache = rmd_params$debug_cache}

deseq_data <- DESeq2::DESeqDataSetFromMatrix(
  countData = counts %>% as.data.frame(),
  colData = col_data,
  design = ~ source + treatment + source:treatment,
  tidy = TRUE
)

deseq_result <- DESeq2::DESeq(deseq_data)
```

</details>

#### Principal Component Analysis

The **P**rincipal **C**omponent **A**nalysis (PCA) shows which samples are similar on a genomic level.
We want our experimental groups to cluster.
If they do not cluster, the variance between the groups is too low or the variance within the groups is too low.
This yields less differentially expressed genes.

```{r plot-pca}

#' PCA plot for quality control
#' @param dat data frame containing the columns `PC1`, `PC2`, `name` and `group`
#' @param title Additional information to put into the plot title
#' @return ggplot2 object of PCA plot
#' @import ggplot2 magrittr ggrepel
pca_plot <- function(dat, title = "") {
  dat %>%
    ggplot2::ggplot(ggplot2::aes(x = PC1, y = PC2, label = name, colour = group)) +
    ggplot2::geom_point() +
    ggplot2::ggtitle(paste0("PCA ", title)) +
    ggplot2::xlab(paste0("Principal Component 1 (", round(attr(dat, "percentVar")[1] * 100), "% variance explained)")) +
    ggplot2::ylab(paste0("Principal Component 2 (", round(attr(dat, "percentVar")[2] * 100), "% variance explained)")) +
    ggplot2::theme_minimal() +
    ggrepel::geom_text_repel()
}

pca_data <- DESeq2::plotPCA(
  DESeq2::vst(deseq_result, blind = FALSE),
  intgroup = "treatment",
  returnData = TRUE
) %>%
  # Attach source variable to PCA data for filtering
  dplyr::left_join(
    x = .,
    y = col_data %>% dplyr::select(id, source),
    by = c("name" = "id")
  )
# PCA plot of all samples
pca_plot(pca_data, "All samples")

# PCA for each source level
pca_data$source %>%
  levels() %>%
  purrr::walk(function(source_level) {
    pca_data %>%
      dplyr::filter(source == source_level) %>%
      pca_plot(paste0(source_level, " samples")) %>%
      print()
  })
```

### Differentially Expressed (DE) Genes

```{r get-contrasts}
# This works at the moment only for two treatment groups
main_effect_a <- DESeq2::results(
  object = deseq_result,
  contrast = c("treatment", col_data$treatment %>% levels())
) %>%
  rmyknife::deseq2_result_to_tibble()

main_effect_b <-
  DESeq2::results(
    object = deseq_result,
    contrast = list(DESeq2::resultsNames(deseq_result)[3:4])
  ) %>%
  rmyknife::deseq2_result_to_tibble() %>%
  # This effect needs to be inverted
  dplyr::mutate(log2FoldChange = log2FoldChange * -1)

interaction_effect <-
  DESeq2::results(
    object = deseq_result,
    contrast = list(DESeq2::resultsNames(deseq_result)[4])
  ) %>%
  rmyknife::deseq2_result_to_tibble()

source_effect_a <- DESeq2::results(
  object = deseq_result,
  contrast = c("source", col_data$source %>% levels())
) %>%
  rmyknife::deseq2_result_to_tibble()

source_effect_b <- DESeq2::results(
  object = deseq_result,
  contrast = list(c(
    DESeq2::resultsNames(deseq_result)[2],
    DESeq2::resultsNames(deseq_result)[4]
  ))
) %>%
  rmyknife::deseq2_result_to_tibble() %>%
  # This effect needs to be inverted
  dplyr::mutate(log2FoldChange = log2FoldChange * -1)

# source_effect <- DESeq2::results(
#   object = deseq_result,
#   contrast = c("source", col_data$source %>% levels())
# ) %>%
#   rmyknife::deseq2_result_to_tibble()

select_join <- function(dat) {
  dplyr::select(dat, ensembl_gene_id, log2FoldChange, padj)
}

# Create a big data frame containing all comparisons of interest
main_effect_a_comparison_name <- glue::glue("main_effect_in_source_a___{treatment_a}_vs_{treatment_b}_in_{source_a}")
main_effect_b_comparison_name <- glue::glue("main_effect_in_source_b___{treatment_a}_vs_{treatment_b}_in_{source_b}")
source_effect_a_comparison_name <- glue::glue("source_effect_in_main_a___{source_a}_vs_{source_b}_in_{treatment_a}")
source_effect_b_comparison_name <- glue::glue("source_effect_in_main_b___{source_a}_vs_{source_b}_in_{treatment_b}")
de <- dplyr::bind_rows(
  main_effect_a %>%
    select_join() %>%
    dplyr::mutate(comparison = main_effect_a_comparison_name),
  main_effect_b %>%
    select_join() %>%
    dplyr::mutate(comparison = main_effect_b_comparison_name),
  interaction_effect %>%
    select_join() %>%
    dplyr::mutate(comparison = "interaction_effect"),
  source_effect_a %>%
    select_join() %>%
    dplyr::mutate(comparison = source_effect_a_comparison_name),
  source_effect_b %>%
    select_join() %>%
    dplyr::mutate(comparison = source_effect_b_comparison_name)
) %>%
  # Attach variable name
  rmyknife::attach_biomart(
    attributes = c("external_gene_name"),
    ensembl_version = rmd_params$ensembl_version,
    verbose = FALSE
  )

de_wide <- de %>%
  tidyr::pivot_wider(
    names_from = comparison,
    values_from = c(padj, log2FoldChange)
  )
```

Let's check the DE genes for each effect.

```{r de-summary-table, warning = FALSE, message = FALSE}

de %>%
  dplyr::mutate(
    sig_up_regulated = padj <= 0.05 & log2FoldChange > 0,
    sig_down_regulated = padj <= 0.05 & log2FoldChange < 0
  ) %>%
  dplyr::group_by(comparison) %>%
  dplyr::summarise(
    up_regulated = sum(sig_up_regulated, na.rm = TRUE),
    down_regulated = sum(sig_down_regulated, na.rm = TRUE),
  ) %>%
  rmarkdown::paged_table()

```

#### Gene Plots

Because of a technically limitation, please first select a gene of interest here and then open the plot.
Otherwise this will drastically slow down your browser.

```{r prepare-gene-plot}
gene_plot <- function(dat) {
  ggplot2::ggplot(
    data = dat,
    mapping = ggplot2::aes(
      x = group,
      y = value
    )
  ) +
    ggplot2::geom_point(position = "jitter")
}

# Create a tidy long format of counts
plot_dat <- dplyr::left_join(
  x = col_data %>%
    dplyr::mutate(group = glue::glue("{source}_{treatment}")) %>%
    dplyr::select(id, group),
  y = rmd_params$counts %>%
    tidyr::pivot_longer(cols = -ensembl_gene_id, names_to = "sample") %>%
    # Attach variable name
    rmyknife::attach_biomart(
      attributes = "external_gene_name",
      ensembl_version = rmd_params$ensembl_version,
      verbose = FALSE
    ),
  by = c("id" = "sample")
) %>%
  # Filtr all genes where we do not get a gene name
  dplyr::filter(!is.na(external_gene_name)) %>%
  # Create a unique gene_id variable for filtering
  dplyr::mutate(
    gene_id = paste0(ensembl_gene_id, "_", external_gene_name)
  ) %>%
  # Attach p-value from interaction effect
  dplyr::left_join(
    de %>%
      tidyr::pivot_wider(names_from = comparison, values_from = c(padj, log2FoldChange)) %>%
      dplyr::select(ensembl_gene_id, padj_interaction_effect),
    by = "ensembl_gene_id"
  ) %>%
  # Filter only for genes with significant interaction effect
  dplyr::filter(padj_interaction_effect <= 0.05) %>%
  dplyr::filter(!is.na(padj_interaction_effect)) %>%
  dplyr::arrange(padj_interaction_effect)

# We have to have at least one differentially expressed gene with the
# interaction term, otherwise we cannot create the SharedData object.
# If we have 0, then just use the original plot_dat
if (nrow(plot_dat) > 0) {
  # The white space after the group is actually important. Otherwise the groups
  # of the two crosstalk objects will be linked. Brushing a gene in one will also
  # do so in the other plot
  plot_dat_sd <- plot_dat %>% crosstalk::SharedData$new(~gene_id, group = "Choose a gene ")
  crosstalk::filter_select(
    id = "gene",
    label = "Select Gene",
    sharedData = plot_dat_sd,
    group = ~gene_id,
    multiple = FALSE
  )
} else {
  plot_dat_sd <- plot_dat
  de_sd <- de
}
```

<details>
<summary>Plot</summary>

```{r gene-plot}

plot_dat_sd %>%
  gene_plot() %>%
  plotly::ggplotly(dynamicTicks = TRUE)
```

</details>

```{r datatable, warning = FALSE}

de_wide %>%
  dplyr::mutate(
    gene_id = paste0(ensembl_gene_id, "_", external_gene_name)
  ) %>%
  dplyr::select(-ensembl_gene_id, -external_gene_name) %>%
  dplyr::select(gene_id, dplyr::everything()) %>%
  # Round all values to 4 decimals
  dplyr::mutate_if(is.numeric, round, 4) %>%
  crosstalk::SharedData$new(~gene_id, group = "Choose a gene") %>%
  DT::datatable(
    # extensions = c("Scroller", "ColReorder", "FixedColumns"),
    extensions = c("Scroller"),
    # class = "compact",
    # style="bootstrap",
    options = list(
      # dom = "t",
      scrollX = TRUE,
      # colReorder = list(realtime = FALSE),
      # fixedColumns = list(leftColumns = 2),
      # Makes the table more responsive when it's really big
      scrollY = 300,
      scroller = TRUE # ,
      # deferRender = TRUE
    )
    # extensions = "Scroller",
    # style = "bootstrap",
    # class = "compact",
    # options = list(deferRender = TRUE)
  )
```

```{r interactive-scatterplot}
fc_scatterplot <-
  function(
           ggplot_dat,
           colour_lab,
           title,
           x_lab = "fc_ip",
           y_lab = "fc_input",
           point_alpha = 0.3) {
    ggplot_dat +
      ggplot2::geom_point(
        alpha = point_alpha
      ) +
      ggplot2::scale_x_continuous(limits = c(-5, 5)) +
      ggplot2::scale_y_continuous(limits = c(-5, 5)) +
      ggplot2::labs(
        # x = x_lab,
        # y = y_lab,
        colour = colour_lab
      ) +
      # ggplot2::scale_size(trans = 'reverse') +
      ggplot2::scale_color_distiller(palette = "RdBu", type = "div", direction = -1, limits = c(-5, 5)) +
      ggplot2::theme_minimal() +
      ggplot2::ggtitle(title)
  }

plot <- de_wide %>%
  dplyr::filter(padj_interaction_effect <= 0.05) %>%
  # Some genes names are encoded multiple times by different ensembl gene ids
  # We therfore need to concatinate the two
  dplyr::mutate(
    gene_id = glue::glue("{ensembl_gene_id}_{external_gene_name}")
  ) %>%
  #  crosstalk::SharedData$new(~gene_id, group = "Choose a gene") %>%
  ggplot2::ggplot(
    mapping = ggplot2::aes_string(
      x = glue::glue("log2FoldChange_{main_effect_a_comparison_name}"),
      # x = "log2FoldChange_main_effect_in_source_a(ip_vs_input_in_il6)",
      y = glue::glue("log2FoldChange_{main_effect_b_comparison_name}"),
      # y = "log2FoldChange_main_effect_in_source_b(ip_vs_input_in_nacl)",
      color = "log2FoldChange_interaction_effect",
      label = "external_gene_name"
    )
  ) %>%
  fc_scatterplot(
    colour_lab = "FC interaction effect",
    title = "FC main effect coloured by FC interaction effect",
    point_alpha = 1
  )

plot %>%
  plotly::ggplotly() %>%
  plotly::highlight(
    on = "plotly_click",
    off = "plotly_doubleclick",
    dynamic = FALSE,
    color = "red",
    selectize = TRUE
  )
```

<details>
<summary>Supplementary plots</summary>

```{r de-plot}
de_wide %>%
  dplyr::mutate(interaction_significant = padj_interaction_effect <= 0.05) %>%
  ggplot2::ggplot(
    mapping = ggplot2::aes_string(
      x = glue::glue("log2FoldChange_{main_effect_a_comparison_name}"),
      y = glue::glue("log2FoldChange_{main_effect_b_comparison_name}"),
      color = "log2FoldChange_interaction_effect",
      shape = "interaction_significant"
    )
  ) %>%
  fc_scatterplot(
    colour_lab = "fc_interaction",
    title = "FC main effect coloured by FC interaction effect",
    point_alpha = 1
  )
```

```{r additional-de-plot}
de_wide %>%
  # dplyr::filter(padj_source_effect_a <= 0.05) %>%
  dplyr::filter(get(glue::glue("padj_{source_effect_a_comparison_name}")) <= 0.05) %>%
  ggplot2::ggplot(
    mapping = ggplot2::aes_string(
      x = glue::glue("log2FoldChange_{main_effect_a_comparison_name}"),
      y = glue::glue("log2FoldChange_{main_effect_b_comparison_name}"),
      color = glue::glue("log2FoldChange_{source_effect_a_comparison_name}")
    )
  ) %>%
  fc_scatterplot(
    title = "FC Treatment in IP and Input with color of IP vs Input (in 'A' samples)",
    colour_lab = "FC source A"
  )

de_wide %>%
  dplyr::filter(get(glue::glue("padj_{source_effect_b_comparison_name}")) <= 0.05) %>%
  ggplot2::ggplot(
    mapping = ggplot2::aes_string(
      x = glue::glue("log2FoldChange_{main_effect_a_comparison_name}"),
      y = glue::glue("log2FoldChange_{main_effect_b_comparison_name}"),
      color = glue::glue("log2FoldChange_{source_effect_b_comparison_name}")
    )
  ) %>%
  fc_scatterplot(
    title = "FC Treatment in IP and Input with color of IP vs Input (in 'B' samples)",
    colour_lab = "FC source B"
  )
```

Let's check how big the overlap between source and interaction is.

```{r overlap-source-interaction}
# de_wide %>%
#   dplyr::mutate(
#     source_a_regulated = padj_source_effect_a <= 0.05,
#     source_b_regulated = padj_source_effect_b <= 0.05,
#     interaction_regulated = padj_interaction_effect <= 0.05
#   ) %>%
#   dplyr::select(source_a_regulated, source_b_regulated, interaction_regulated) %>%
#   # Replace NA values by "FALSE"
#   replace(is.na(.), FALSE) %>%
#   ComplexUpset::upset(intersect = colnames(.))
```

</details>

```{r save_result, cache = rmd_params$debug_cache}

if (rmd_params$save_rds) {
  saveRDS(
    object = de,
    file = glue::glue("{rmd_params$path_out}/de.rds")
  )
  saveRDS(
    object = col_data,
    file = glue::glue("{rmd_params$path_out}/col_data.rds")
  )
  saveRDS(
    object = counts %>%
      tidyr::pivot_longer(cols = -ensembl_gene_id, names_to = "sample") %>%
      # Attach variable name
      rmyknife::attach_biomart(
        attributes = "external_gene_name",
        ensembl_version = rmd_params$ensembl_version,
        verbose = FALSE
      ),
    file = glue::glue("{rmd_params$path_out}/counts.rds")
  )
}

if (rmd_params$save_excel) {
  rmyknife::write_xls(
    dat = de_wide,
    ExcelFileName = glue::glue("{rmd_params$path_out}/de.xlsx"),
    SheetNames = "trapDiff Output"
  )
}
```